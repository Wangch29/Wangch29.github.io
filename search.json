[{"title":"Project 3 leaderboard ä¼˜åŒ–","url":"/2024/12/08/Bustub/project3-leaderboard/","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"å‰è¨€\"><a href=\"#å‰è¨€\" class=\"headerlink\" title=\"å‰è¨€\"></a>å‰è¨€</h1><p>è¿™æ˜¯ä¸€ä¸ªå…³äºæˆ‘è‡ªå·±çš„cmu15-445 project 3 leaderboardéƒ¨åˆ†çš„æ”»ç•¥ï¼Œä¸ä¼šæ¶‰åŠå…¶å‰é¢åŸºç¡€å®ç°éƒ¨åˆ†ã€‚æœ€ç»ˆæ•ˆæœä¸‰ä¸ªéƒ¨åˆ†å¹³å‡ç”¨æ—¶2000ä»¥å†…ï¼Œè¿›äº†æ’è¡Œæ¦œå‰åã€‚</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/059ce9aa4865460797af7c48176abc08.png#pic_center\"><br>å¼•è‡ª<a href=\"https://www.cnblogs.com/joey-wang/p/17351258.html\">joey-wang</a></p>\n<h1 id=\"Query-1-TopNPerGroupPlan\"><a href=\"#Query-1-TopNPerGroupPlan\" class=\"headerlink\" title=\"Query 1: TopNPerGroupPlan\"></a>Query 1: TopNPerGroupPlan</h1><p>æ ¹æ®ä¾‹å­ï¼š</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t1(x <span class=\"type\">INT</span>, y <span class=\"type\">INT</span>, z <span class=\"type\">INT</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> x, y <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> x, y, <span class=\"built_in\">rank</span>() <span class=\"keyword\">OVER</span> (<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> x <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> y) <span class=\"keyword\">as</span> rank</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> t1</span><br><span class=\"line\">) <span class=\"keyword\">WHERE</span> rank <span class=\"operator\">&lt;=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>é¦–å…ˆå¯ä»¥é€šè¿‡Bustub shell é‡Œçš„ explain å¾—å…¶ç›®å‰çš„ plan treeï¼Œæ¥åˆ†æä¸€ä¸‹æ‰§è¡Œè¿‡ç¨‹:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;] &#125;</span><br><span class=\"line\">  Filter &#123; predicate=(#0.2&lt;=3) &#125;</span><br><span class=\"line\">    WindowFunc &#123;</span><br><span class=\"line\">      columns=#0.0, #0.1, placeholder, ,</span><br><span class=\"line\">      window_functions=&#123;</span><br><span class=\"line\">        2=&gt;&#123; function_arg=1, type=rank, partition_by=[&quot;#0.0&quot;], order_by=[(&quot;Default&quot;, &quot;#0.1&quot;)] &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      SeqScan &#123; table=t1 &#125;</span><br></pre></td></tr></table></figure>\n\n<p>å¯çœ‹å‡ºå…¶æœ‰å››ä¸ªplan nodeï¼Œæ‰§è¡Œé¡ºåºå¦‚ä¸‹ï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Seqscan -&gt; WindowFunc -&gt; Filter -&gt; Projection</span><br></pre></td></tr></table></figure>\n\n<p>å½“æ»¡è¶³Projection &lt;-Filter &lt;- WindowFuncé¡ºåºï¼Œä¸”projectionå°†windowFuncäº§ç”Ÿçš„rankåˆ—æ¸…é™¤æ—¶ï¼Œå®ƒä»¬ä¸‰ä¸ªnodeå¯ä»¥åˆå¹¶æˆä¸€ä¸ªTopNPerGroupPlanï¼Œæ‰«æåç›´æ¥è¿”å›æ¯ä¸ªgroupæ’åå‰Nçš„tupleï¼Œå³ï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Seqscan -&gt; TopNPerGroupPlan</span><br></pre></td></tr></table></figure>\n<p>å³å¯åœ¨optimizer.hæ–°å¢ä¸€ä¸ªä¼˜åŒ–patternï¼š</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">OptimizeProjectionFilterWindowAsTopGroupN</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef</span>;</span><br></pre></td></tr></table></figure>\n<p>ä½ ä¼šå‘ç°åŸæœ¬bustubè‡ªå¸¦çš„ä¼˜åŒ–methodå®ç°éƒ½æ˜¯åœ¨ä¸€ä¸ªæ–°çš„.cppæ–‡ä»¶ä¸­ï¼Œä¸ºäº†ç»Ÿä¸€æ ¼å¼ä½ è‡ªç„¶ä¼šæƒ³åˆ°æ–°åˆ›å»ºä¸€ä¸ªOptimizeProjectionFilterWindowAsTopGroupN.cppæ¥å®ç°è¯¥å‡½æ•°ï¼Œå†åŠ å…¥cmakelistsé‡Œã€‚ä½†äº‹ä¸æ„¿è¿ï¼Œç”±äºgradescopeçš„é™åˆ¶ï¼Œå¦‚æœä½ æƒ³çº¿ä¸Šæµ‹è¯•ï¼Œå°±ä¸èƒ½è‡ªå·±æ–°å»ºæ–‡ä»¶ï¼Œè€Œè¦åœ¨é¡¹ç›®æŒ‡å®šoptimizer_custom_rules.cppé‡Œå®ç°ã€‚è¿™ç‚¹ä¼šè®©optimizer_custom_rules.cppå¾€åå˜çš„å¾ˆè‡ƒè‚¿ï¼Œå¸Œæœ›è¯¾ç¨‹ä»¥åèƒ½æ”¹è¿›è¿™ä¸€ç‚¹å§ã€‚ã€‚ã€‚</p>\n<p>ä¸»è¦æ€è·¯æ˜¯åˆ©ç”¨ä¸€ä¸ªå¯ä»¥ä¿ç•™å¤šä¸ªtuple çš„ç‰¹æ®Špriority queueæ¥ä¸ºæ¯ä¸ªç»„ä¿ç•™top Nä¸ªtupleã€‚æ³¨æ„å¦‚æœæœ‰ç›¸ç­‰çš„tupleï¼Œéœ€è¦åŒæ—¶ä¿ç•™ï¼Œä¾‹å­å¯è§p3.leaderboard_test_q1_windowã€‚è¿˜è¦ç”¨ä¸€ä¸ªhashmap æ¥åˆ†ç»„ã€‚è¿‡ç¨‹å°±æ˜¯ï¼šå…ˆæ‹¿åˆ°ä¸€ä¸ªtupleï¼Œç„¶åè·å¾—å…¶groupå€¼ï¼Œåˆ©ç”¨groupå€¼åškeyåœ¨ä¸€ä¸ª<strong>hashmap</strong>ä¸­æ‰¾åˆ°å…¶æ‰€åœ¨groupå¯¹åº”çš„priority queueï¼Œç„¶åæ’å…¥ã€‚è¿™æ—¶å€™åªéœ€è¦<strong>è‡ªå®šä¹‰ä¸€ä¸‹è¿™ä¸ªpriority queueï¼Œè®©å…¶è‡ªåŠ¨ä¿å­˜å‰nä¸ªtupleå°±å¯ä»¥äº†ã€‚</strong></p>\n<p>å¯¹äºOptimizeProjectionFilterWindowAsTopGroupNï¼Œåˆ™æ˜¯ä¾æ¬¡æŸ¥çœ‹ä¸‰å±‚nodeplanï¼Œå¦‚æœæ»¡è¶³â€œ<em><strong>Projection &lt;-Filter &lt;- WindowFuncé¡ºåºï¼Œä¸”projectionå°†windowFuncäº§ç”Ÿçš„rankåˆ—æ¸…é™¤æ—¶</strong></em>â€ï¼Œå³å¯ä¼˜åŒ–æˆTopNPerGroup nodeã€‚å¯ä»¥åˆ©ç”¨shellä¸­çš„explain (o)è¯­å¥æ¥æŸ¥çœ‹ä¼˜åŒ–æ˜¯å¦æˆåŠŸã€‚</p>\n<p>å…·ä½“å®ç°å¦‚ä¸‹ï¼š</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizeProjectionFilterWindowAsTopGroupN</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; optimized_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    optimized_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeProjectionFilterWindowAsTopGroupN</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> optimized_plan = plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(optimized_children));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// First node is Projection.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode &amp;&gt;(*optimized_plan);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> &amp;first_child = projection_plan.<span class=\"built_in\">GetChildren</span>().<span class=\"built_in\">at</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Second node is filter.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first_child-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Filter) &#123;</span><br><span class=\"line\">      <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;filter_child = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> FilterPlanNode &amp;&gt;(*first_child);</span><br><span class=\"line\">      <span class=\"comment\">// auto filter_logic_expr = dynamic_cast&lt;const LogicExpression&amp;&gt;(filter_child.predicate_);</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> &amp;second_child = filter_child.<span class=\"built_in\">GetChildren</span>().<span class=\"built_in\">at</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"comment\">// Third node is window.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (second_child-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Window) &#123;</span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;window_child = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> WindowFunctionPlanNode &amp;&gt;(*second_child);</span><br><span class=\"line\">        <span class=\"comment\">// Try to find Rank&#x27;s col index.</span></span><br><span class=\"line\">        <span class=\"type\">int</span> rank_idx = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        std::string rank_name;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> col = <span class=\"number\">0</span>; col &lt; window_child.columns_.<span class=\"built_in\">size</span>(); ++col) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (window_child.window_functions_.<span class=\"built_in\">find</span>(rank_idx) != window_child.window_functions_.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Is a window function</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (window_child.window_functions_.<span class=\"built_in\">at</span>(rank_idx).type_ == WindowFunctionType::Rank) &#123;</span><br><span class=\"line\">              rank_idx = col;</span><br><span class=\"line\">              rank_name = window_child.<span class=\"built_in\">OutputSchema</span>().<span class=\"built_in\">GetColumn</span>(rank_idx).<span class=\"built_in\">GetName</span>();</span><br><span class=\"line\">              <span class=\"keyword\">goto</span> OptimizeProjectionFilterWindowAsTopGroupN_END;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// If we find Rank, we can continue to check if it stays after projection.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rank_idx != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;projection_schema = projection_plan.<span class=\"built_in\">OutputSchema</span>();</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;column : projection_schema.<span class=\"built_in\">GetColumns</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (column.<span class=\"built_in\">GetName</span>() == rank_name) &#123;  <span class=\"comment\">// Find the rank line</span></span><br><span class=\"line\">              <span class=\"keyword\">goto</span> OptimizeProjectionFilterWindowAsTopGroupN_END;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Projection removed RANK, we can optimize it to TopGroupN node.</span></span><br><span class=\"line\">        <span class=\"comment\">// Find group_bys</span></span><br><span class=\"line\">        <span class=\"type\">const</span> std::vector&lt;AbstractExpressionRef&gt; &amp;group_by =</span><br><span class=\"line\">            window_child.window_functions_.<span class=\"built_in\">begin</span>()-&gt;second.partition_by_;</span><br><span class=\"line\">        <span class=\"comment\">// Find order by</span></span><br><span class=\"line\">        <span class=\"type\">const</span> std::vector&lt;std::pair&lt;OrderByType, AbstractExpressionRef&gt;&gt; &amp;order_by =</span><br><span class=\"line\">            window_child.window_functions_.<span class=\"built_in\">begin</span>()-&gt;second.order_by_;</span><br><span class=\"line\">        <span class=\"comment\">// Find top n;</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> value_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ConstantValueExpression &amp;&gt;(*filter_child.predicate_-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"comment\">// auto value_expr = dynamic_cast&lt;const ConstantValueExpression &amp;&gt;(*maybe_value_expr);</span></span><br><span class=\"line\">        <span class=\"type\">int</span> n = value_expr.val_.<span class=\"built_in\">CastAs</span>(TypeId::INTEGER).<span class=\"built_in\">GetAs</span>&lt;<span class=\"type\">int</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;TopNPerGroupPlanNode&gt;(projection_plan.output_schema_, window_child.children_.<span class=\"built_in\">at</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">                                                      group_by, order_by, n);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">OptimizeProjectionFilterWindowAsTopGroupN_END:</span><br><span class=\"line\">  <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>åœ¨topn_per_group_executor.cppï¼š</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TopNPerGroupExecutor::Init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  child_executor_-&gt;<span class=\"built_in\">Init</span>();</span><br><span class=\"line\">  partition_top_n_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"type\">size_t</span> top_n = plan_-&gt;n_;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> group_by = plan_-&gt;<span class=\"built_in\">GetGroupBy</span>();</span><br><span class=\"line\">  <span class=\"function\">CompareTuple <span class=\"title\">comparator</span><span class=\"params\">(&amp;plan_-&gt;GetOrderBy(), &amp;child_executor_-&gt;GetOutputSchema())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Use a priority queue to store the top N tuples for each group.</span></span><br><span class=\"line\">  Tuple tuple;</span><br><span class=\"line\">  RID rid;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (child_executor_-&gt;<span class=\"built_in\">Next</span>(&amp;tuple, &amp;rid)) &#123;   <span class=\"comment\">// nlogn</span></span><br><span class=\"line\">    AggregateKey group_by_key = <span class=\"built_in\">ConstructGroupByTuple</span>(tuple, group_by);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = partition_top_n_.<span class=\"built_in\">find</span>(group_by_key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (partition_top_n_.<span class=\"built_in\">find</span>(group_by_key) == partition_top_n_.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      it = partition_top_n_.<span class=\"built_in\">emplace</span>(group_by_key, <span class=\"built_in\">TopNTuplePriorityQueue</span>(top_n, comparator)).first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    it-&gt;second.<span class=\"built_in\">Push</span>(tuple);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  iter_ = partition_top_n_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">TopNPerGroupExecutor::Next</span><span class=\"params\">(Tuple *tuple, RID *rid)</span> -&gt; <span class=\"type\">bool</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (iter_ != partition_top_n_.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iter_-&gt;second.<span class=\"built_in\">Empty</span>()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Move to the next pq, and erase current pq.</span></span><br><span class=\"line\">      iter_ = partition_top_n_.<span class=\"built_in\">erase</span>(iter_);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Next</span>(tuple, rid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *tuple = iter_-&gt;second.<span class=\"built_in\">Pop</span>();</span><br><span class=\"line\">    *rid = tuple-&gt;<span class=\"built_in\">GetRid</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>è‡ªå®šä¹‰ç‰ˆpriority queueï¼š</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TopNTuplePriorityQueue</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">TopNTuplePriorityQueue</span><span class=\"params\">(std::<span class=\"type\">size_t</span> n, CompareTuple comparator)</span></span></span><br><span class=\"line\"><span class=\"function\">      : n_(n), pq_(comparator), freq_map_(comparator) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Push</span><span class=\"params\">(<span class=\"type\">const</span> Tuple &amp;tuple)</span> </span>&#123;</span><br><span class=\"line\">    pq_.<span class=\"built_in\">push</span>(tuple);</span><br><span class=\"line\">    freq_map_[tuple] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">MaintainSize</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> -&gt; Tuple </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pq_.<span class=\"built_in\">empty</span>()) [[unlikely]] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> std::<span class=\"built_in\">runtime_error</span>(<span class=\"string\">&quot;TopNTuplePriorityQueue is empty&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Tuple top_tuple = pq_.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    pq_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_tuple;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Empty</span><span class=\"params\">()</span> -&gt; <span class=\"type\">bool</span> </span>&#123; <span class=\"keyword\">return</span> pq_.<span class=\"built_in\">empty</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  std::<span class=\"type\">size_t</span> n_;</span><br><span class=\"line\">  std::priority_queue&lt;Tuple, std::vector&lt;Tuple&gt;, CompareTuple&gt; pq_;</span><br><span class=\"line\">  std::map&lt;Tuple, <span class=\"type\">size_t</span>, CompareTuple&gt; freq_map_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MaintainSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pq_.<span class=\"built_in\">size</span>() &gt; n_) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If removing top elements will lead to underflow, break;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (pq_.<span class=\"built_in\">size</span>() - freq_map_[pq_.<span class=\"built_in\">top</span>()] &lt; n_) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Remove top tuples.</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (freq_map_[pq_.<span class=\"built_in\">top</span>()] &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        freq_map_[pq_.<span class=\"built_in\">top</span>()] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        pq_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      freq_map_.<span class=\"built_in\">erase</span>(pq_.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">      pq_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>åœ¨top_n_per_group.hä¸­çš„TupleComparatorå’Œå…¶ä»–ä¸€äº›ä¸œè¥¿å°±ç•™ç»™è¯»è€…æ€è€ƒï¼Œä¸å†™å‡ºäº†ï¼Œå…·ä½“æ€è·¯æˆ‘å·²ç»åœ¨ä¸Šé¢è®²è¿‡äº†ã€‚è€Œè¿™ä¸ªç©æ„çš„è¾“å‡ºä¸éœ€è¦æŒ‰ç…§ä¸€å®šé¡ºåºæ¯”å¦‚å‡åºï¼Œåªéœ€è¦è·å¾—çš„tupleå¯¹å°±è¡Œã€‚</p>\n<p>è‡³æ­¤å³å¯é€šè¿‡leaderboard test q1ï¼Œæˆ‘çš„ç”¨æ—¶ç›®å‰æ˜¯7000å¤šï¼Œæ’åå¤šåï¼Œåœ¨åšäº†ä¼˜åŒ–çš„äººä¸­ç®—æ˜¯æ…¢çš„äº†ï¼Œçœ‹æ¥è¿˜æœ‰ä¼˜åŒ–ç©ºé—´ã€‚</p>\n<p>åšä¸ªprofilingçœ‹çœ‹ğŸ‘€ï¼š<br><img src=\"https://i-blog.csdnimg.cn/direct/bc28397020ab4437bbce3ac400b42368.png#pic_center\" alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\"><br>æˆ‘å‘ç°TopNTuplePriorityQueueä¸­çš„**MaintainSize()<strong>å‡½æ•°æ¯”æˆ‘æƒ³è±¡çš„è€—æ—¶é—´ã€‚MaintainSizeå æ®äº†Pushè¿‡åŠçš„æ—¶é—´ï¼Œè€Œ</strong>freq_map_[]**åˆå æ®äº†MaintainSizeè¿‡åŠçš„æ—¶é—´ï¼Œæ‰€ä»¥ç”¨åŸºäºçº¢é»‘æ ‘çš„mapè¿˜æ˜¯ä¸è¡Œï¼Œå¯ä»¥æŠŠ std::map&lt;Tuple, size_t, CompareTuple&gt; freq_map_ ä¼˜åŒ–æˆ unordered_mapã€‚</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MaintainSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (pq_.<span class=\"built_in\">size</span>() &gt; n_) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If removing top elements will lead to underflow, break;</span></span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> top_tuple_freq = freq_map_[pq_.<span class=\"built_in\">top</span>()];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pq_.<span class=\"built_in\">size</span>() - top_tuple_freq &lt; n_) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Remove top tuples.</span></span><br><span class=\"line\">        freq_map_.<span class=\"built_in\">erase</span>(pq_.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; top_tuple_freq; ++i) &#123;</span><br><span class=\"line\">          pq_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">std::unordered_map&lt;Tuple, <span class=\"type\">size_t</span>, TupleHash, TupleEqual&gt; freq_map_;</span><br></pre></td></tr></table></figure>\n\n<p>ç„¶åå†æµ‹è¯•ï¼Œå‘ç°å±…ç„¶q1ç”¨æ—¶ç›´æ¥ä»7000å¤šå‡å°‘åˆ°äº†4000å¤šï¼Œå¿«äº†40%å¤šï¼Œæ•ˆæœååˆ†æ˜¾è‘—å•Šã€‚å¯è§profilingå¯¹ä¼˜åŒ–çš„æŒ‡å¯¼è¿˜æ˜¯å¾ˆæœ‰æ•ˆçš„ã€‚</p>\n<p>ä¼˜åŒ–åå†åšä¸ªprofilingï¼š<br><img src=\"https://i-blog.csdnimg.cn/direct/56f81ad3ada240c29acd9eecd359ed73.png#pic_center\" alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\"><br>å¯è§Push()ç”¨æ—¶å¤§å¹…ç¼©çŸ­ã€‚ä½†leaderboardä¸Šè¿˜æœ‰ç¥äººèƒ½ä¼˜åŒ–åˆ°1000å¤šï¼ŒçœŸä¸çŸ¥æ€ä¹ˆåšåˆ°çš„ã€‚</p>\n<h1 id=\"Query-2-Too-Many-Joins\"><a href=\"#Query-2-Too-Many-Joins\" class=\"headerlink\" title=\"Query 2: Too Many Joins!\"></a>Query 2: Too Many Joins!</h1><h2 id=\"è§£æ\"><a href=\"#è§£æ\" class=\"headerlink\" title=\"è§£æ\"></a>è§£æ</h2><p>ä¸€åæ¥è‡ª<a href=\"https://zh.wikipedia.org/wiki/%E8%8C%83%E5%B0%8F%E5%8B%A4\">ä¸¥è¾‰æ‘</a>çš„æ‘æ°‘å†™äº†å¦‚ä¸‹çš„sqlï¼š</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t4(x <span class=\"type\">int</span>, y <span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t5(x <span class=\"type\">int</span>, y <span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t6(x <span class=\"type\">int</span>, y <span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t4, t5, t6</span><br><span class=\"line\">  <span class=\"keyword\">WHERE</span> (t4.x <span class=\"operator\">=</span> t5.x) <span class=\"keyword\">AND</span> (t5.y <span class=\"operator\">=</span> t6.y) <span class=\"keyword\">AND</span> (t4.y <span class=\"operator\">&gt;=</span> <span class=\"number\">1000000</span>)</span><br><span class=\"line\">    <span class=\"keyword\">AND</span> (t4.y <span class=\"operator\">&lt;</span> <span class=\"number\">1500000</span>) <span class=\"keyword\">AND</span> (t6.x <span class=\"operator\">&gt;=</span> <span class=\"number\">100000</span>) <span class=\"keyword\">AND</span> (t6.x <span class=\"operator\">&lt;</span> <span class=\"number\">150000</span>);</span><br></pre></td></tr></table></figure>\n<p>å¯è§ä»–å…¶å®æƒ³å§<strong>t4ã€t5 join on x, t5ã€t6 join on y</strong>, ä½†æ˜¯å¹¶æ²¡æœ‰äººä¸ºåœ°åˆ†æ­¥åˆå¹¶ï¼Œè€Œæ˜¯ä¸€è‚¡è„‘åœ°æŠŠæ¡ä»¶å…¨æ”¾åœ¨äº†<strong>where</strong>åé¢ã€‚å¦‚æœæ²¡æœ‰ä¼˜åŒ–ï¼Œå°±å¯¼è‡´è¯¥queryæ‰§è¡Œçš„æ—¶å€™ä¼šæŠŠt4ã€t5ã€t6åšä¸¤ä¸ªç¬›å¡å°”ç§¯ï¼ˆ<strong>Cartesian product</strong>ï¼Œå³æ— æ¡ä»¶çš„joinï¼‰ç”Ÿäº§ä¸€ä¸ªå·¨å¤§çš„tableï¼Œç„¶åéå†è¿™ä¸ªå·¨å¤§çš„tableè¿›è¡Œè¿‡æ»¤ã€‚</p>\n<p>å½“ç„¶ï¼Œä½ åœ¨å‰é¢å·²ç»å®ç°äº†åŒ…æ‹¬<strong>hash join</strong>åœ¨å†…çš„éƒ¨åˆ†ä¼˜åŒ–å™¨ï¼Œæ‰€ä»¥å®é™…ä¸Šæ ¹æ®æˆ‘ä¸ªäººå‰é¢çš„å®ç°ï¼Œä¼šå…ˆå¯¹t4ã€t5è¿›è¡Œä¸€ä¸ªåŸºäºhash joinçš„ç¬›å¡å°”ç§¯ï¼Œç„¶åå†å’Œt6è¿›è¡Œä¸€ä¸ªæœ‰æ¡ä»¶çš„hash joinï¼Œæœ€åè¿›è¡Œä¸€ä¸ªè¿‡æ»¤ï¼ˆfilter nodeï¼‰ã€‚</p>\n<p>å…·ä½“ç»è¿‡ç”¨explain (o)å¯çœ‹å…¶plan tree:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">Filter &#123; predicate=(((((#0.0=#0.2)and(#0.1&gt;=1000000))and(#0.1&lt;1500000))and</span><br><span class=\"line\">(#0.4&gt;=100000))and(#0.4&lt;150000)) &#125; | </span><br><span class=\"line\">(t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">  HashJoin &#123; type=Inner, left_key=[&quot;#0.3&quot;], right_key=[&quot;#1.1&quot;] &#125; | </span><br><span class=\"line\">  (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\">  </span><br><span class=\"line\">    HashJoin &#123; type=Inner, left_key=[], right_key=[] &#125; | </span><br><span class=\"line\">    (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">      SeqScan &#123; table=t4 &#125; | (t4.x:INTEGER, t4.y:INTEGER)</span><br><span class=\"line\">      SeqScan &#123; table=t5 &#125; | (t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    SeqScan &#123; table=t6 &#125; | (t6.x:INTEGER, t6.y:INTEGER)</span><br></pre></td></tr></table></figure>\n<p>è¿™ä¸ªæ ¹æ®æ¯ä¸ªäººä¹‹å‰å¯¹<strong>Optimizer::OptimizeNLJAsHashJoin(</strong>)å®ç°çš„ä¸åŒï¼Œè¿™é‡Œçš„æƒ…å†µä¹Ÿä¼šæœ‰ä¸åŒã€‚</p>\n<h2 id=\"å…³äºHash-Join\"><a href=\"#å…³äºHash-Join\" class=\"headerlink\" title=\"å…³äºHash Join\"></a>å…³äºHash Join</h2><p>è€ŒOptimizeNLJAsHashJoinå…¶å®è¿˜æŒºç¹ççš„ï¼Œæ ¹æ®æˆ‘å¯¹gradescopeä¸Šleaderboardçš„è§‚å¯Ÿï¼Œæœ‰å¾ˆå¤šäººå¯¹è¿™ä¸ªå‡½æ•°çš„å®ç°å…¶å®çš„é”™è¯¯çš„ï¼Œ<strong>åªæ˜¯å› ä¸ºgradescopeä¸Šçš„åŸºç¡€æµ‹è¯•å¹¶ä¸å…¨é¢ï¼Œä»–ä»¬æ‰é€šè¿‡äº†é™¤leaderboardå¤–å…¶ä½™çš„åŸºç¡€æµ‹è¯•</strong>ã€‚è€Œåˆ°äº†leaderboardæµ‹è¯•ï¼Œå°±ä¼šå‡ºç°bugäº†ã€‚</p>\n<p>æ‰€ä»¥æˆ‘è®²ä¸€ä¸‹æˆ‘çš„hashjoinçš„å®ç°æ€è·¯ï¼šå¤§æ¦‚æ˜¯ç”¨ä¸€ä¸ªé€’å½’éå†NLJ_plan.predicateçš„treeï¼Œå½“å‘ç°<strong>ColumnValueExpression</strong>ä¸”åˆ¤æ–­å¼ä¸ºequalä¸”å…¶å·¦å³å­©å­expressionå‡ä¸ºColumnValueExpressionä¸”GetTupleIdx()åˆ†åˆ—å·¦å³çš„æ—¶å€™ï¼Œå°†å…¶åŠ å…¥hash joinå¹¶ä»åŸexpression treeä¸­åˆ é™¤ã€‚è€Œéå†åå‰©ä¸‹çš„expression treeåˆ™ç”¨äºåˆ›å»ºä¸€ä¸ªfilteræ”¾åœ¨hash join ä¸Šæ–¹ã€‚è€Œä¸”åœ¨ç”Ÿæˆfilterçš„æ—¶å€™è¦è®°å¾—ä¿®æ”¹ColumnValueExpressionçš„col_idxã€‚</p>\n<p>ä¸¾ä¸ªä¾‹å­ï¼š</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t4, t5</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> (t4.x <span class=\"operator\">=</span> t5.x) <span class=\"keyword\">AND</span> (t4.x <span class=\"operator\">=</span> t4.y) <span class=\"keyword\">AND</span> (t4.z <span class=\"operator\">&gt;=</span> t5.z) <span class=\"keyword\">AND</span> (t5.x <span class=\"operator\">=</span> <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n<p>è¿™ä¸ªqueryä¼šè¢«ä¼˜åŒ–æˆï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Filter: (t4.x = t4.y) AND (t4.z &gt;= t5.z) AND (t5.z = 100)</span><br><span class=\"line\">         â”‚</span><br><span class=\"line\">         â””â”€â”€ HashJoin: t4.x = t5.x</span><br><span class=\"line\">             â”œâ”€â”€ Sequential Scan: t4</span><br><span class=\"line\">             â””â”€â”€ Sequential Scan: t5</span><br></pre></td></tr></table></figure>\n<p>å››ä¸ªæ¡ä»¶åªæœ‰$t4.x &#x3D; t5.x$èƒ½è¢«æ”¾å…¥hash join, å› ä¸º$t4.x &#x3D; t4.y$åªä½œç”¨åœ¨left childï¼Œ $t4.z &gt;&#x3D; t5.z$ä¸æ˜¯ç­‰å¼è€Œæ˜¯ä¸ç­‰å¼ï¼Œ$t5.x &#x3D; 100$åªä½œç”¨äºright childä¸”æœ‰ä¸€ä¸ªå¸¸æ•°é¡¹ã€‚æ‰€ä»¥è¿™ä¸‰ä¸ªåˆ¤æ–­éƒ½ä¸Šç§»åˆ°filterã€‚</p>\n<p>è€Œè¿˜è¦è€ƒè™‘æ›´å¤æ‚çš„NLJçš„æ¡ä»¶ä¸­logicè¿æ¥è¯ä¸º<strong>OR</strong>çš„æƒ…å†µï¼Œå¦‚:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t4, t5</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> (t4.x <span class=\"operator\">=</span> t5.x) <span class=\"keyword\">OR</span> (t4.y <span class=\"operator\">=</span> t5.y);</span><br></pre></td></tr></table></figure>\n<p>æˆ‘ç›®å‰çš„åšæ³•æ˜¯å¦‚æœå­˜åœ¨ORå°±ç›´æ¥ä¿æŒNLJï¼Œä½†å…¶å®å¯ä»¥è¿™æ ·ä¼˜åŒ–æˆï¼š</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> t4, t5</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> t4.x <span class=\"operator\">=</span> t5.x</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> t4, t5</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> t4.y <span class=\"operator\">=</span> t5.y;</span><br></pre></td></tr></table></figure>\n<p>æˆ–è€…ç”¨treeè¡¨è¾¾ï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Union All</span><br><span class=\"line\">â”œâ”€â”€ HashJoin: t4.x = t5.x</span><br><span class=\"line\">â”‚   â”œâ”€â”€ Sequential Scan: t4</span><br><span class=\"line\">â”‚   â””â”€â”€ Sequential Scan: t5</span><br><span class=\"line\">â””â”€â”€ HashJoin: t4.y = t5.y</span><br><span class=\"line\">    â”œâ”€â”€ Sequential Scan: t4</span><br><span class=\"line\">    â””â”€â”€ Sequential Scan: t5</span><br></pre></td></tr></table></figure>\n<p>å³å°†ORè¿æ¥çš„éƒ¨åˆ†æ‹†åˆ†æˆä¸¤ä¸ªhash joinï¼Œç„¶åå†Unionèµ·æ¥ã€‚</p>\n<h2 id=\"ä¼˜åŒ–\"><a href=\"#ä¼˜åŒ–\" class=\"headerlink\" title=\"ä¼˜åŒ–\"></a>ä¼˜åŒ–</h2><p>å›åˆ°æ­£é¢˜ï¼Œè¿™ä¸ªqueryå°±æ˜¯æ•…æ„è®¾è®¡ä¸€ä¸ªpredicateé›†ä¸­åˆ†å¸ƒåœ¨node treeä¸Šæ–¹ï¼Œä¸»è¦è€ƒå¯Ÿçš„æ˜¯ä¼˜åŒ–å™¨å¯¹predicate pushdownçš„èƒ½åŠ›ã€‚</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Filter &#123; predicate=(((((#0.0=#0.2)and(#0.1&gt;=1000000))and(#0.1&lt;1500000))and</span><br><span class=\"line\">(#0.4&gt;=100000))and(#0.4&lt;150000)) &#125; | </span><br><span class=\"line\">(t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">  HashJoin &#123; type=Inner, left_key=[&quot;#0.3&quot;], right_key=[&quot;#1.1&quot;] &#125; | </span><br><span class=\"line\">  (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\">  </span><br><span class=\"line\">    HashJoin &#123; type=Inner, left_key=[], right_key=[] &#125; | </span><br><span class=\"line\">    (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">      SeqScan &#123; table=t4 &#125; | (t4.x:INTEGER, t4.y:INTEGER)</span><br><span class=\"line\">      SeqScan &#123; table=t5 &#125; | (t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    SeqScan &#123; table=t6 &#125; | (t6.x:INTEGER, t6.y:INTEGER)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Query Plan Node Tree</span><br><span class=\"line\"></span><br><span class=\"line\">Filter: (t4.y = t5.y) AND (t4.x &gt;= 1000000)) AND (t4.x &lt; 1500000)) </span><br><span class=\"line\">|\t\t\tAND (t6.x &gt;= 100000)) AND (t6.x &lt; 150000))</span><br><span class=\"line\">â”‚</span><br><span class=\"line\">â””â”€â”€ HashJoin: t5.y = t6.y</span><br><span class=\"line\">    â”œâ”€â”€ HashJoin: t4.x = t5.x</span><br><span class=\"line\">    â”‚   â”œâ”€â”€ Sequential Scan: t4</span><br><span class=\"line\">    â”‚   â””â”€â”€ Sequential Scan: t5</span><br><span class=\"line\">    â””â”€â”€ Sequential Scan: t6</span><br></pre></td></tr></table></figure>\n<p>ç”»å‡ºplan node tree å¯ä»¥çœ‹å‡ºï¼Œæ ¹æ®æˆ‘ä¹‹å‰çš„å®ç°ï¼Œpredicateéƒ½é£˜åœ¨æœ€ä¸Šæ–¹ï¼Œç°åœ¨è¦åšçš„æ˜¯æŠŠpredicateä¸‹æ¨ï¼Œå…¶åœ¨åç»­ä¼˜åŒ–å‡½æ•°çš„ä½œç”¨ä¸‹å¯ä»¥ä¸<strong>NLJã€seq_scan</strong>ç­‰nodeåˆå¹¶ã€‚</p>\n<p>åœ¨optimizer.hæ–°å¢ä¼˜åŒ–å‡½æ•°ï¼š</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">OptimizePredicatePushdown</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef</span>;</span><br></pre></td></tr></table></figure>\n<p>åŒæ ·åœ¨optimizer_custom_rules.cppä¸­å®ç°ï¼š</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizePredicatePushdown</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; optimized_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    optimized_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizePredicatePushdown</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> optimized_plan = plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(optimized_children));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Plan Should be a filter node.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Filter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> filter_plan = <span class=\"built_in\">dynamic_cast</span>&lt;FilterPlanNode *&gt;(optimized_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    std::vector&lt;std::shared_ptr&lt;ComparisonExpression&gt;&gt; pushdowns;</span><br><span class=\"line\">    filter_plan-&gt;predicate_ = <span class=\"built_in\">ParsePredicate</span>(filter_plan-&gt;predicate_, filter_plan-&gt;<span class=\"built_in\">OutputSchema</span>(), pushdowns);</span><br><span class=\"line\">    <span class=\"comment\">// No predicate could be pushed down, simply return.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pushdowns.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// All predicate could be pushed down, remove the filter node.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filter_plan-&gt;predicate_ == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Pushdown</span>(filter_plan-&gt;children_[<span class=\"number\">0</span>], pushdowns);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Part of predicate could be pushed down.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> filter_plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(&#123;<span class=\"built_in\">Pushdown</span>(filter_plan-&gt;children_[<span class=\"number\">0</span>], pushdowns)&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>è¿˜æœ‰å‡ ä¸ªhelper methodæˆ‘å°±ä¸æ”¾å‡ºäº†ï¼Œè¯´ä¸€ä¸‹æ€è·¯ï¼š</p>\n<p>é¦–å…ˆè¦è·å–predicateï¼Œ è€Œpredicateå­˜åœ¨filter nodeä¸­ï¼Œæ‰€ä»¥å½“é‡åˆ°ä¸€ä¸ªfilter nodeï¼Œç”¨<strong>ParsePredicate()</strong> æ¥è·å–predicateã€‚è¿™ä¸ªå‡½æ•°è¾“å…¥å€¼<strong>filter_plan-&gt;predicate_<strong>æ˜¯ä¸€ä¸ªtreeï¼Œé€’å½’éå†å¤„ç†è¿™ä¸ªtreeï¼Œå°†ç”¨</strong>AND</strong>è¿æ¥çš„<strong>ComparisonExpression</strong>åŠ å…¥<strong>pushdowns</strong>è¿™ä¸ªvectorï¼Œé‡åˆ°ORåˆ™åœæ­¢ç›´æ¥ä¿æŒåŸæ ·è¿”å›ã€‚åŠ å…¥pushdownsçš„expressionè¦ä»åŸæ ‘ä¸­å‰”é™¤ã€‚</p>\n<p>è¿™æ ·å°±è·å¾—äº†éœ€è¦ä¸‹æ¨çš„predicatesï¼Œå°†è¿™äº›predicateså’Œå­èŠ‚ç‚¹æ”¾å…¥ä¸‹æ¨å‡½æ•°**Pushdown()**ã€‚Pushdownä¸­å¯¹é‡åˆ°çš„å„ç§ç±»å‹çš„plan nodeåˆ†ç±»å¤„ç†ï¼Œæœ‰çš„å¯ä»¥ç›´æ¥è·³è¿‡ï¼Œæœ‰çš„ä¼šé˜»å¡ä¸‹æ¨ï¼Œæœ‰çš„ä¼šä½¿ä¸‹æ¨åˆ†å‰(join node)ã€‚ ç±»ä¼¼ï¼š</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::Pushdown</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                         std::vector&lt;std::shared_ptr&lt;ComparisonExpression&gt;&gt; &amp;pushdowns)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pushdowns.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> plan;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Check if plan is Filter.</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (plan-&gt;<span class=\"built_in\">GetType</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::NestedLoopJoin: &#123;</span><br><span class=\"line\">      TODO: ... ... </span><br><span class=\"line\">      <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Skip these nodes.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Filter:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Limit:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Sort: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::vector&lt;AbstractPlanNodeRef&gt;&#123;<span class=\"built_in\">Pushdown</span>(plan-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">0</span>), pushdowns)&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Block pushdown, generate a filter plan above it.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::SeqScan:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::MockScan:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Aggregation:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Window:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Delete:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Update:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Insert:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Projection:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::InitCheck: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;FilterPlanNode&gt;(plan-&gt;output_schema_, <span class=\"built_in\">ConcatencateComparisonAnd</span>(pushdowns), plan);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Advanced planNode, they should be generated latter.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::TopNPerGroup:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::TopN:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::HashJoin:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::NestedIndexJoin: &#123;</span><br><span class=\"line\">      <span class=\"built_in\">UNREACHABLE</span>(<span class=\"string\">&quot;This kind of node should not appear in pushdown. They should be made after pushdown.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">      <span class=\"built_in\">UNREACHABLE</span>(<span class=\"string\">&quot;Not supported planNode type.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>å…¶ä¸­æœ€å¤æ‚çš„å°±æ˜¯é‡åˆ°<strong>NestedLoopJoin</strong>ï¼Œè®°å¾—è¦ä¿®æ”¹åƒå³å­æ ‘ç»§ç»­ä¸‹æ¨çš„predicatesçš„<strong>col_idx</strong>ã€‚</p>\n<p>å½“æ¨åˆ°å¯ä»¥åˆå¹¶çš„èŠ‚ç‚¹ï¼Œå¦‚seq_scanã€NLJçš„æ—¶å€™ï¼Œåªéœ€è¦åœ¨å…¶ä¸Šæ–¹å»ºä¸€ä¸ªfilter nodeï¼Œå› ä¸ºåç»­å…¶ä»–çš„ä¼˜åŒ–å‡½æ•°ä¼šå¸®ä½ åˆå¹¶ã€‚è€Œ<strong>OptimizePredicatePushdown</strong>æˆ‘æ˜¯æ”¾åœ¨äº†<strong>Optimizer::OptimizeCustom</strong>ä¸­çš„é å‰ä½ç½®ï¼Œè¿™æ ·å¯ä»¥å…ˆä¸‹æ¨ï¼Œå†åˆå¹¶ï¼Œä¼˜åŒ–è°ƒç†æ¸…æ™°ï¼Œå……åˆ†åˆ©ç”¨å·²ç»å†™å¥½çš„å…¶ä»–ä¼˜åŒ–å‡½æ•°ã€‚</p>\n<p>å®ç°ä¸‹æ¨åï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">HashJoin &#123; type=Inner, left_key=[&quot;#0.3&quot;], right_key=[&quot;#1.1&quot;] &#125; </span><br><span class=\"line\">| (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">HashJoin &#123; type=Inner, left_key=[&quot;#0.0&quot;], right_key=[&quot;#1.0&quot;] &#125; </span><br><span class=\"line\">| (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">SeqScan &#123; table=t4, filter=((#0.1&lt;1500000)and(#0.1&gt;=1000000)) &#125; </span><br><span class=\"line\">| (t4.x:INTEGER, t4.y:INTEGER)</span><br><span class=\"line\">   </span><br><span class=\"line\">SeqScan &#123; table=t5 &#125; | (t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">SeqScan &#123; table=t6, filter=((#0.0&lt;150000)and(#0.0&gt;=100000)) &#125;</span><br><span class=\"line\">| (t6.x:INTEGER, t6.y:INTEGER)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HashJoin: t4.y = t6.y</span><br><span class=\"line\">| Output: (t4.x, t4.y, t5.x, t5.y, t6.x, t6.y)</span><br><span class=\"line\">â”‚</span><br><span class=\"line\">â”œâ”€â”€ HashJoin: t4.x = t5.x</span><br><span class=\"line\">â”‚   | Output: (t4.x, t4.y, t5.x, t5.y)</span><br><span class=\"line\">â”‚   â”‚</span><br><span class=\"line\">â”‚   â”œâ”€â”€ SeqScan: table=t4</span><br><span class=\"line\">â”‚   â”‚   | Filter: (t4.y &gt;= 1000000) AND (t4.y &lt; 1500000)</span><br><span class=\"line\">â”‚   â”‚   | Output: (t4.x, t4.y)</span><br><span class=\"line\">â”‚   â”‚</span><br><span class=\"line\">â”‚   â””â”€â”€ SeqScan: table=t5</span><br><span class=\"line\">â”‚       | No Filter</span><br><span class=\"line\">â”‚       | Output: (t5.x, t5.y)</span><br><span class=\"line\">â”‚</span><br><span class=\"line\">â””â”€â”€ SeqScan: table=t6</span><br><span class=\"line\">    | Filter: (t6.x &gt;= 100000) AND (t6.x &lt; 150000)</span><br><span class=\"line\">    | Output: (t6.x, t6.y)</span><br></pre></td></tr></table></figure>\n<p>å¯çœ‹åˆ°è°“è¯è¢«ä¸‹æ¨åˆ°åˆé€‚çš„åœ°æ–¹äº†ã€‚</p>\n<p>æ­¤æ—¶leaderboard q2ç”¨æ—¶1900å¤šï¼Œæ’åç¬¬å…«ã€‚</p>\n<h2 id=\"è¿›ä¸€æ­¥ä¼˜åŒ–æƒ³æ³•\"><a href=\"#è¿›ä¸€æ­¥ä¼˜åŒ–æƒ³æ³•\" class=\"headerlink\" title=\"è¿›ä¸€æ­¥ä¼˜åŒ–æƒ³æ³•\"></a>è¿›ä¸€æ­¥ä¼˜åŒ–æƒ³æ³•</h2><ol>\n<li><strong>Joiné‡æ’ join reorder</strong>ã€‚å…ˆä¼°ç®—è¡¨çš„å¤§å°ï¼Œç„¶åé‡æ’è¿æ¥é¡ºåºï¼Œå…ˆjoinå°è¡¨åjoinå¤§è¡¨ã€‚</li>\n<li><strong>å®ç°Hash joinçš„æ¯”è¾ƒå·¦å³è¡¨</strong>ã€‚ä¼°ç®—å·¦å³è¡¨å¤§å°ï¼Œä»è€Œç”¨å°è¡¨æ„é€ hash mapã€‚</li>\n<li><strong>limit&#x2F;agg ä¸‹æ¨</strong>ã€‚ä½†leaderboard testä¸­æ²¡æœ‰é’ˆå¯¹æ­¤çš„æµ‹è¯•ï¼Œæ‰€ä»¥å®ç°äº†å¯¹æ’åæé«˜æ— ç”¨ã€‚</li>\n<li><strong>queryå¤ç”¨è®¡ç®—ç»“æœ</strong>ã€‚leaderboardæµ‹è¯•é€»è¾‘è²Œä¼¼æ˜¯æŠŠåŒä¸€ä¸ªqueryæ‰§è¡Œ10æ¬¡ï¼Œæ‰€ä»¥å®ç°å‚¨å­˜queryç»“æœå¤ç”¨æœ‰å¯èƒ½å¯ä»¥å¤§å¹…åŠ é€Ÿç¬¬2ï½10æ¬¡queryã€‚</li>\n</ol>\n<h1 id=\"Query-3-The-Mad-Data-Scientist\"><a href=\"#Query-3-The-Mad-Data-Scientist\" class=\"headerlink\" title=\"Query 3: The Mad Data Scientist\"></a>Query 3: The Mad Data Scientist</h1><p>ä¸€åè´­ä¹°äº†æ’å¤ªæˆ¿äº§çš„æ•°æ®ç§‘å­¦å®¶æ„è¯†åˆ°è‡ªå·±çš„æ‰€ä½œæ‰€ä¸ºä¹‹åï¼Œå†™ä¸‹äº†è¿™äº›å¥‡æ€ªçš„queryï¼š</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t7(v <span class=\"type\">int</span>, v1 <span class=\"type\">int</span>, v2 <span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t8(v4 <span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">explain <span class=\"keyword\">SELECT</span> v, d1, d2 <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> v,</span><br><span class=\"line\">         <span class=\"built_in\">MAX</span>(v1) <span class=\"keyword\">AS</span> d1, <span class=\"built_in\">MIN</span>(v1), <span class=\"built_in\">MAX</span>(v2), <span class=\"built_in\">MIN</span>(v2),</span><br><span class=\"line\">         <span class=\"built_in\">MAX</span>(v1) <span class=\"operator\">+</span> <span class=\"built_in\">MIN</span>(v1), <span class=\"built_in\">MAX</span>(v2) <span class=\"operator\">+</span> <span class=\"built_in\">MIN</span>(v2),</span><br><span class=\"line\">         <span class=\"built_in\">MAX</span>(v1) <span class=\"operator\">+</span> <span class=\"built_in\">MAX</span>(v1) <span class=\"operator\">+</span> <span class=\"built_in\">MAX</span>(v2) <span class=\"keyword\">AS</span> d2</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> t7 <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> (<span class=\"keyword\">SELECT</span> v4 <span class=\"keyword\">FROM</span> t8 <span class=\"keyword\">WHERE</span> <span class=\"number\">1</span> <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">2</span>) <span class=\"keyword\">ON</span> v <span class=\"operator\">&lt;</span> v4</span><br><span class=\"line\">    <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> v</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>å¯ä»¥çœ‹åˆ°æœ‰å¾ˆå¤šå¥‡æ€ªçš„ä¸œè¥¿ï¼Œæ¯”å¦‚å§‹ç»ˆç­‰äºfalseçš„</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"number\">1</span> <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>è¿˜æœ‰è®¡ç®—äº†è¿™äº›æ•°æ®ï¼Œä½†å¹¶æ²¡æœ‰è¾“å‡ºï¼š</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">MIN</span>(v1), <span class=\"built_in\">MAX</span>(v2), <span class=\"built_in\">MIN</span>(v2),</span><br><span class=\"line\"><span class=\"built_in\">MAX</span>(v1) <span class=\"operator\">+</span> <span class=\"built_in\">MIN</span>(v1), <span class=\"built_in\">MAX</span>(v2) <span class=\"operator\">+</span> <span class=\"built_in\">MIN</span>(v2),</span><br></pre></td></tr></table></figure>\n<p>ç¬¬ä¸€ä¸ªå§‹ç»ˆç­‰äºfalseçš„è¡¨è¾¾å¼è€ƒå¯Ÿçš„æ˜¯ä¼˜åŒ–å™¨**å¸¸é‡æŠ˜å (constant folding)<strong>èƒ½åŠ›ï¼Œè€Œç¬¬äºŒä¸ªå»é™¤å†—ä½™çš„è®¡ç®—è€ƒå¯Ÿçš„æ˜¯ä¼˜åŒ–å™¨åˆ—</strong>å‰ªæ(Column pruning)**çš„èƒ½åŠ›ã€‚</p>\n<p>å…ˆçœ‹çœ‹ä¼˜åŒ–å‰ï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;, &quot;#0.7&quot;] &#125; | (__subquery#0.t7.v:INTEGER, __subquery#0.d1:INTEGER, __subquery#0.d2:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">  Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;, &quot;#0.3&quot;, &quot;#0.4&quot;, &quot;(#0.5+#0.6)&quot;, &quot;(#0.7+#0.8)&quot;, &quot;((#0.9+#0.10)+#0.11)&quot;] &#125; | (__subquery#0.t7.v:INTEGER, __subquery#0.d1:INTEGER, __subquery#0.__item#2:INTEGER, __subquery#0.__item#3:INTEGER, __subquery#0.__item#4:INTEGER, __subquery#0.__item#5:INTEGER, __subquery#0.__item#6:INTEGER, __subquery#0.d2:INTEGER)</span><br><span class=\"line\">  </span><br><span class=\"line\">    Agg &#123; types=[&quot;max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;max&quot;, &quot;max&quot;], </span><br><span class=\"line\">    aggregates=[&quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;, &quot;#0.2&quot;, &quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;, &quot;#0.2&quot;, &quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;], </span><br><span class=\"line\">    group_by=[&quot;#0.0&quot;] &#125;</span><br><span class=\"line\">   \t| (t7.v:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER, agg#3:INTEGER, agg#4:INTEGER, agg#5:INTEGER, agg#6:INTEGER, agg#7:INTEGER, agg#8:INTEGER, agg#9:INTEGER, agg#10:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">      Filter &#123; predicate=(#0.0&lt;#0.3) &#125; | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER, __subquery#1.t8.v4:INTEGER)</span><br><span class=\"line\">      </span><br><span class=\"line\">        HashJoin &#123; type=Left, left_key=[], right_key=[] &#125; | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER, __subquery#1.t8.v4:INTEGER)</span><br><span class=\"line\">        </span><br><span class=\"line\">          SeqScan &#123; table=t7 &#125; | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER)</span><br><span class=\"line\">          </span><br><span class=\"line\">          SeqScan &#123; table=t8, filter=(1=2) &#125; | (t8.v4:INTEGER)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection: (__subquery#0.t7.v, __subquery#0.d1, __subquery#0.d2)</span><br><span class=\"line\">â”‚</span><br><span class=\"line\">â””â”€â”€ Projection: (__subquery#0.t7.v, __subquery#0.d1, __subquery#0.d2, derived columns)</span><br><span class=\"line\">    â”‚</span><br><span class=\"line\">    â””â”€â”€ Aggregation: Group by (t7.v), Aggregates: max/min</span><br><span class=\"line\">        â”‚</span><br><span class=\"line\">        â””â”€â”€ Filter: (t7.v &lt; __subquery#1.t8.v4)</span><br><span class=\"line\">            â”‚</span><br><span class=\"line\">            â””â”€â”€ HashJoin: Left Join (t7, t8)</span><br><span class=\"line\">                â”‚</span><br><span class=\"line\">                â”œâ”€â”€ Sequential Scan: t7</span><br><span class=\"line\">                â”‚</span><br><span class=\"line\">                â””â”€â”€ Sequential Scan: t8 (filtered: (1=2) )</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"å¸¸é‡æŠ˜å -Constant-Folding\"><a href=\"#å¸¸é‡æŠ˜å -Constant-Folding\" class=\"headerlink\" title=\"å¸¸é‡æŠ˜å  Constant Folding\"></a>å¸¸é‡æŠ˜å  Constant Folding</h2><p>å¸¸é‡æŠ˜å æŒ‡çš„æ˜¯ä¼˜åŒ–å™¨æå‰å°†å¯ä»¥è®¡ç®—çš„è¡¨è¾¾å¼è®¡ç®—å‡ºç»“æœï¼Œå¦åˆ™æ¯æ¥ä¸€ä¸ªtupleï¼Œè¡¨è¾¾å¼å°±è¦é‡æ–°è®¡ç®—ä¸€æ¬¡ã€‚</p>\n<p>åœ¨optimizer.hä¸­å¢åŠ declarationï¼Œå¹¶åœ¨optimizer_custom_rules.cppä¸­å®ç°ï¼š</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizeConstantFolding</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; optimized_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    optimized_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeConstantFolding</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> optimized_plan = plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(optimized_children));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// For filter, folding its predicate.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Filter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> filter_plan = <span class=\"built_in\">dynamic_cast</span>&lt;FilterPlanNode *&gt;(optimized_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> new_predicate = <span class=\"built_in\">FoldingPredicate</span>(filter_plan-&gt;predicate_);</span><br><span class=\"line\">    <span class=\"comment\">// If the new_predicate is constant, </span></span><br><span class=\"line\">    <span class=\"comment\">// true, return its child; false, return an empty value node.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> new_predicate_const = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ConstantValueExpression *&gt;(new_predicate.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_predicate_const-&gt;<span class=\"built_in\">Evaluate</span>(&#123;&#125;, <span class=\"built_in\">Schema</span>(&#123;&#125;)).<span class=\"built_in\">GetAs</span>&lt;<span class=\"type\">bool</span>&gt;()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> plan-&gt;children_[<span class=\"number\">0</span>];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;ValuesPlanNode&gt;(plan-&gt;output_schema_, std::vector&lt;std::vector&lt;AbstractExpressionRef&gt;&gt;&#123;&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// new_predicate is not a constant, return a new filter.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;FilterPlanNode&gt;(filter_plan-&gt;output_schema_, new_predicate, filter_plan-&gt;children_[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>å®ç°å¸¸é‡æŠ˜å åï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Query Execution Plan</span><br><span class=\"line\"></span><br><span class=\"line\">Projection: (output columns: #0.0, #0.1, #0.7)</span><br><span class=\"line\">â”‚</span><br><span class=\"line\">â””â”€â”€ Projection: (output columns: #0.0, #0.1, #0.2, #0.3, #0.4, (#0.5 + #0.6), (#0.7 + #0.8), ((#0.9 + #0.10) + #0.11))</span><br><span class=\"line\">    â”‚</span><br><span class=\"line\">    â””â”€â”€ Aggregation: Group By (#0.0), Aggregates (max/min on #0.1, #0.2)</span><br><span class=\"line\">        â”‚</span><br><span class=\"line\">        â””â”€â”€ Filter: (#0.0 &lt; #0.3)</span><br><span class=\"line\">            â”‚</span><br><span class=\"line\">            â””â”€â”€ HashJoin: Left Join</span><br><span class=\"line\">                â”‚</span><br><span class=\"line\">                â”œâ”€â”€ Sequential Scan: t7</span><br><span class=\"line\">                â”‚</span><br><span class=\"line\">                â””â”€â”€ Values: (empty set, rows=0)</span><br></pre></td></tr></table></figure>\n<p>å¯è§seq_scan t8 è¢«æŠ˜å æˆç©ºçš„Value nodeäº†ã€‚æ­¤æ—¶å¯ä»¥å¯¹Joinè¿›è¡Œä¼˜åŒ–ï¼Œå¦‚æœå³å­©ä¸ºç©ºï¼Œç›´æ¥è¿”å›å·¦å­©(left join)æˆ–ç›´æ¥è¿”å›false(inner join)ã€‚<strong>ä½†ç›®å‰ä¸å¯ä»¥ç›´æ¥åˆ é™¤Joinï¼Œå› ä¸ºjoinä¹‹åschemaä¼šæ”¹å˜ã€‚</strong></p>\n<p>æ­¤æ—¶åªæŠ˜å äº†filteré‡Œçš„expressionsï¼Œè¿™è™½ç„¶å·²ç»è¶³å¤Ÿåº”ä»˜æµ‹è¯•ï¼Œä½†ä½ è¿˜å¯ä»¥å°†å…¶ä½™æœ‰expressionsçš„planéƒ½ç»™æŠ˜å äº†ï¼Œè¿™å°±ä¸è´´å‡ºæ¥äº†ï¼Œç•™ç»™è¯»è€…å®ç°ã€‚</p>\n<h2 id=\"åˆ—å‰ªæ-ColumnPruning\"><a href=\"#åˆ—å‰ªæ-ColumnPruning\" class=\"headerlink\" title=\"åˆ—å‰ªæ ColumnPruning\"></a>åˆ—å‰ªæ ColumnPruning</h2><p>å¯ä»¥çœ‹åˆ°å®ç°å¸¸é‡æŠ˜å åçš„æ‰§è¡Œæ ‘ä¸­ï¼Œ</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection: (output columns: #0.0, #0.1, #0.7)</span><br></pre></td></tr></table></figure>\n<p>æœ€ç»ˆç»“æœåªè¾“å‡º#0.0 #0.1 #0.7ï¼Œä½†aggregateå´è®¡ç®—äº†ä¸€é•¿ä¸²ï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection: (output columns: #0.0, #0.1, #0.2, #0.3, #0.4, (#0.5 + #0.6), (#0.7 + #0.8), ((#0.9 + #0.10) + #0.11)</span><br></pre></td></tr></table></figure>\n<p>æ‰€ä»¥å½“Projectionçš„å­èŠ‚ç‚¹ä¸ºProjectionæˆ–è€…Aggregationçš„æ—¶å€™ï¼Œå¯ä»¥å¯¹å­èŠ‚ç‚¹è¿›è¡Œå‰ªæï¼Œé¿å…ä¸éœ€è¦çš„è®¡ç®—å’Œå†…å­˜å ç”¨ã€‚æ³¨æ„ï¼ŒColumn Pruningä¸€å®šè¦è‡ªä¸Šè€Œä¸‹ï¼Œå¦åˆ™ä¼šå¯¼è‡´pruningä¸å®Œå…¨ã€‚</p>\n<p>ç¬¬äºŒä¸ªprojectionåº”prunedä¸ºï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection: (output columns: #0.0, #0.1, #0.2, #0.3, #0.4, (#0.5 + #0.6), (#0.7 + #0.8), ((#0.9 + #0.10) + #0.11))</span><br><span class=\"line\">\t\t\t\t\t\t\tï½œ</span><br><span class=\"line\">\t\t\t\t\t\t\tï½œ</span><br><span class=\"line\">\t\t\t\t\t\t\t\\/</span><br><span class=\"line\">Projection: (output columns: #0.0, #0.1, ((#0.9 + #0.10) + #0.11))\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br></pre></td></tr></table></figure>\n\n<p>å¯¹äº Projection ç»“ç‚¹, åˆ†åˆ«å¤„ç†å­ç»“ç‚¹ä¸º Projection å’Œ Aggregation çš„æƒ…å†µ.</p>\n<ul>\n<li>å¯¹äº Projection ç»“ç‚¹, ç”¨çˆ¶èŠ‚ç‚¹å¯¹å­ç»“ç‚¹ä¿®å‰ª, ç„¶åç”¨å­ç»“ç‚¹æ›¿æ¢çˆ¶èŠ‚ç‚¹.</li>\n<li>å¯¹äº Aggregation ç»“ç‚¹, ç”¨ Projection ä¸­å‡ºç°çš„åˆ—æ£€æŸ¥ Aggregation ä¸­æ˜¯å¦å‡ºç°, è‹¥æ²¡æœ‰åˆ™åˆ é™¤. åŒæ—¶æ£€æŸ¥æ˜¯å¦å­˜åœ¨å†—ä½™, è‹¥å­˜åœ¨åˆ™åˆ é™¤.<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizeColumnPruning</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;<span class=\"type\">const</span> AbstractPlanNode&gt; optimized_plan = plan;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode *&gt;(optimized_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> child_plan = projection_plan-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pruning when child is Projection.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Collect used cols.</span></span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">uint32_t</span>&gt; used_col_idxs;</span><br><span class=\"line\">      used_col_idxs.<span class=\"built_in\">reserve</span>(optimized_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumnCount</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CollectUsedColumnIdx</span>(expr, used_col_idxs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      std::<span class=\"built_in\">sort</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">      <span class=\"comment\">// Prune child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> child_projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode *&gt;(child_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_exprs;</span><br><span class=\"line\">      std::vector&lt;Column&gt; pruned_columns;</span><br><span class=\"line\">      pruned_exprs.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_columns.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> idx : used_col_idxs) &#123;</span><br><span class=\"line\">        pruned_exprs.<span class=\"built_in\">push_back</span>(child_projection_plan-&gt;expressions_[idx]);</span><br><span class=\"line\">        pruned_columns.<span class=\"built_in\">push_back</span>(child_projection_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(idx));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Replace parent by its optimized child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> optimized_child_plan = std::<span class=\"built_in\">make_shared</span>&lt;ProjectionPlanNode&gt;(std::<span class=\"built_in\">make_shared</span>&lt;Schema&gt;(pruned_columns), </span><br><span class=\"line\">          pruned_exprs, child_plan-&gt;children_[<span class=\"number\">0</span>]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">OptimizeColumnPruning</span>(optimized_child_plan);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pruning when child is Aggregation.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Aggregation) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Collect used cols.</span></span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">uint32_t</span>&gt; used_col_idxs;</span><br><span class=\"line\">      used_col_idxs.<span class=\"built_in\">reserve</span>(optimized_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumnCount</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CollectUsedColumnIdx</span>(expr, used_col_idxs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      std::<span class=\"built_in\">sort</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">      <span class=\"comment\">// Prune child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> child_aggregation_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> AggregationPlanNode *&gt;(child_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">      <span class=\"type\">size_t</span> group_col_length = child_aggregation_plan-&gt;group_bys_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_aggregates;</span><br><span class=\"line\">      std::vector&lt;AggregationType&gt; pruned_agg_types;</span><br><span class=\"line\">      std::vector&lt;Column&gt; pruned_columns;</span><br><span class=\"line\">      pruned_aggregates.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_agg_types.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_columns.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; group_col_length; ++i) &#123;</span><br><span class=\"line\">        pruned_columns.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(i));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> idx : used_col_idxs) &#123; <span class=\"comment\">// Maybe optimized to binary, upper_bound.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt;= group_col_length) &#123;</span><br><span class=\"line\">          pruned_aggregates.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;aggregates_[idx - group_col_length]);</span><br><span class=\"line\">          pruned_agg_types.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;agg_types_[idx - group_col_length]);</span><br><span class=\"line\">          pruned_columns.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(idx));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Make new optimized node child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> optimized_aggr = std::<span class=\"built_in\">make_shared</span>&lt;AggregationPlanNode&gt;(</span><br><span class=\"line\">          std::<span class=\"built_in\">make_shared</span>&lt;Schema&gt;(pruned_columns), child_aggregation_plan-&gt;children_[<span class=\"number\">0</span>], </span><br><span class=\"line\">          child_aggregation_plan-&gt;group_bys_, pruned_aggregates, pruned_agg_types);</span><br><span class=\"line\">      <span class=\"comment\">// Modified parent node schema and expr.</span></span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_exprs;</span><br><span class=\"line\">      pruned_exprs.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        pruned_exprs.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">PrunedProjectionExpression</span>(expr, used_col_idxs));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      optimized_plan = std::<span class=\"built_in\">make_shared</span>&lt;ProjectionPlanNode&gt;(projection_plan-&gt;output_schema_, pruned_exprs, optimized_aggr);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> optimized_plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(&#123;<span class=\"built_in\">OptimizeColumnPruning</span>(optimized_plan-&gt;children_[<span class=\"number\">0</span>])&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::SeqScan || optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::MockScan ||</span><br><span class=\"line\">      optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::IndexScan) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; new_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    new_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeColumnPruning</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(new_children));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nåˆ°äº†è¿™é‡Œï¼Œæˆ‘ä¹Ÿå‘ç°äº†æˆ‘OptimizeNLJAsHashJoin()çš„ä¸€ä¸ªbugï¼Œè¦åœ¨OptimizeNLJAsHashJoin()ä¸­éœ€è¦åŠ ä¸€è¡Œï¼š<strong>å½“å°è¯•åœ¨Join Nodeä¸Šæ–¹ç”Ÿæˆæ–°çš„filter Nodeæ—¶å€™ï¼Œå¦‚joinç±»å‹ä¸æ˜¯Inner Join, è¦ä¿æŒNLJè€Œä¸èƒ½ä¼˜åŒ–æˆHash_Join</strong>ã€‚</li>\n</ul>\n<p>æˆ‘å®ç°OptimizeNLJAsHashJoin()çš„æ—¶å€™ä¼šå°è¯•å¤šç”Ÿæˆä¸€ä¸ªfilter Nodeï¼Œä½†æ˜¯å¦‚æœæ˜¯Left Join çš„è¯ï¼ŒJoinåçš„tupleä¸­æœ‰å¯èƒ½å‡ºç°null valueï¼Œè€Œæ–°çš„fileræœ‰å¯èƒ½ä¼šå¯¼è‡´è¿™äº›åŒ…å«null valueçš„tupleå…¨è¢«å»é™¤æ‰ã€‚æ‰€ä»¥åœ¨Left Joinçš„æ—¶å€™ï¼Œè¦ä¿æŒå»é™¤çš„åˆ¤æ–­è¯­å¥åœ¨Join Nodeå†…éƒ¨ï¼Œè€Œä¸èƒ½å‰¥ç¦»å¼€ã€‚æ‰€ä»¥å…¶å®gradescopeä¸Šç»™çš„åŸºç¡€æµ‹è¯•éå¸¸ä¸å…¨é¢ï¼Œå³ä½¿é€šè¿‡æ‰€ä»¥æµ‹è¯•ï¼Œä»£ç ä¹Ÿå¯èƒ½æœ‰å¾ˆå¤šå¾ˆå¤§çš„bugã€‚</p>\n<p>debugå¹¶ä¼˜åŒ–åï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;, &quot;((#0.2+#0.3)+#0.4)&quot;] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Agg &#123; types=[&quot;max&quot;, &quot;max&quot;, &quot;max&quot;, &quot;max&quot;]</span><br><span class=\"line\">  ,aggregates=[&quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;]</span><br><span class=\"line\">  ,group_by=[&quot;#0.0&quot;] &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    NestedLoopJoin &#123; type=Left, predicate=(#0.0&lt;#1.0) &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">      MockScan &#123; table=__mock_t7 &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      Values &#123; rows=0 &#125;</span><br></pre></td></tr></table></figure>\n<p>æ­¤æ—¶å·²ç»å¯ä»¥è¾ƒå¿«åœ°é€šè¿‡q3äº†ï¼Œä½†ä½ ä¼šå‘ç°ï¼Œaggrä¸­å±…ç„¶è¿˜æœ‰é‡å¤çš„è®¡ç®—:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">types=     [&quot;max&quot;,  &quot;max&quot;,  &quot;max&quot;,  &quot;max&quot;],</span><br><span class=\"line\">aggregates=[&quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;]</span><br></pre></td></tr></table></figure>\n<p>å¯¹é½ä¸€ä¸‹ï¼Œæ˜¾ç„¶å¯¹#0.1çš„maxå±…ç„¶è®¡ç®—äº†ä¸‰éâ€¦æ‰€ä»¥å¯ä»¥è¿›ä¸€æ­¥å¯¹aggregationå»é‡ã€‚</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Optimizer::CollectUsedColumnIdx</span><span class=\"params\">(<span class=\"type\">const</span> AbstractExpressionRef &amp;expr, std::vector&lt;<span class=\"type\">uint32_t</span>&gt; &amp;col_idxs)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> *arith_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ArithmeticExpression*&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CollectUsedColumnIdx</span>(expr-&gt;children_[<span class=\"number\">0</span>], col_idxs);</span><br><span class=\"line\">    <span class=\"built_in\">CollectUsedColumnIdx</span>(expr-&gt;children_[<span class=\"number\">1</span>], col_idxs);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> *column_value_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ColumnValueExpression *&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">find</span>(col_idxs.<span class=\"built_in\">begin</span>(), col_idxs.<span class=\"built_in\">end</span>(), column_value_expr-&gt;<span class=\"built_in\">GetColIdx</span>()) == col_idxs.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      col_idxs.<span class=\"built_in\">push_back</span>(column_value_expr-&gt;<span class=\"built_in\">GetColIdx</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ConstantValueExpression *&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  std::string message = <span class=\"string\">&quot;Projection expressions should only contain arithmetic, column and constant: &quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">UNREACHABLE</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::PrunedProjectionExpression</span><span class=\"params\">(<span class=\"type\">const</span> AbstractExpressionRef &amp;expr, std::vector&lt;<span class=\"type\">int</span>&gt; idx_map)</span> </span></span><br><span class=\"line\"><span class=\"function\">    -&gt; AbstractExpressionRef </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Notice: used_col_idxs is sorted.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> *arith_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ArithmeticExpression *&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expr-&gt;<span class=\"built_in\">CloneWithChildren</span>(&#123;<span class=\"built_in\">PrunedProjectionExpression</span>(expr-&gt;children_[<span class=\"number\">0</span>], idx_map),</span><br><span class=\"line\">                                    <span class=\"built_in\">PrunedProjectionExpression</span>(expr-&gt;children_[<span class=\"number\">1</span>], idx_map)&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> *column_value_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ColumnValueExpression *&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> new_col_idx = idx_map[column_value_expr-&gt;<span class=\"built_in\">GetColIdx</span>()];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;ColumnValueExpression&gt;(column_value_expr-&gt;<span class=\"built_in\">GetTupleIdx</span>(), new_col_idx, </span><br><span class=\"line\">        column_value_expr-&gt;<span class=\"built_in\">GetReturnType</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> expr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizeColumnPruning</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;<span class=\"type\">const</span> AbstractPlanNode&gt; optimized_plan = plan;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode *&gt;(optimized_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> child_plan = projection_plan-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pruning when child is Projection.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Collect used cols.</span></span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">uint32_t</span>&gt; used_col_idxs;</span><br><span class=\"line\">      used_col_idxs.<span class=\"built_in\">reserve</span>(optimized_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumnCount</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CollectUsedColumnIdx</span>(expr, used_col_idxs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      std::<span class=\"built_in\">sort</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">      <span class=\"comment\">// Prune child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> child_projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode *&gt;(child_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_exprs;</span><br><span class=\"line\">      std::vector&lt;Column&gt; pruned_columns;</span><br><span class=\"line\">      pruned_exprs.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_columns.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> idx : used_col_idxs) &#123;</span><br><span class=\"line\">        pruned_exprs.<span class=\"built_in\">push_back</span>(child_projection_plan-&gt;expressions_[idx]);</span><br><span class=\"line\">        pruned_columns.<span class=\"built_in\">push_back</span>(child_projection_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(idx));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Replace parent by its optimized child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> optimized_child_plan = std::<span class=\"built_in\">make_shared</span>&lt;ProjectionPlanNode&gt;(std::<span class=\"built_in\">make_shared</span>&lt;Schema&gt;(pruned_columns), </span><br><span class=\"line\">          pruned_exprs, child_plan-&gt;children_[<span class=\"number\">0</span>]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">OptimizeColumnPruning</span>(optimized_child_plan);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pruning when child is Aggregation.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Aggregation) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">auto</span> child_aggregation_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> AggregationPlanNode *&gt;(child_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Collect used cols.</span></span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">uint32_t</span>&gt; used_col_idxs;</span><br><span class=\"line\">      used_col_idxs.<span class=\"built_in\">reserve</span>(optimized_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumnCount</span>());</span><br><span class=\"line\">      <span class=\"type\">size_t</span> group_cols = child_aggregation_plan-&gt;<span class=\"built_in\">GetGroupBys</span>().<span class=\"built_in\">size</span>();</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; group_cols; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Must use group by columns.</span></span><br><span class=\"line\">        used_col_idxs.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CollectUsedColumnIdx</span>(expr, used_col_idxs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      std::<span class=\"built_in\">sort</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Prune child.</span></span><br><span class=\"line\">      <span class=\"type\">size_t</span> group_col_length = child_aggregation_plan-&gt;group_bys_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_aggregates;</span><br><span class=\"line\">      std::vector&lt;AggregationType&gt; pruned_agg_types;</span><br><span class=\"line\">      std::vector&lt;Column&gt; pruned_columns;</span><br><span class=\"line\">      <span class=\"comment\">// For aggr deduplication, [expression.toString + AggregationType]</span></span><br><span class=\"line\">      std::unordered_map&lt;std::string, <span class=\"type\">uint32_t</span>&gt; exist_expr;</span><br><span class=\"line\">      std::unordered_map&lt;<span class=\"type\">uint32_t</span>, <span class=\"type\">uint32_t</span>&gt; re_direct;</span><br><span class=\"line\"></span><br><span class=\"line\">      pruned_aggregates.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_agg_types.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_columns.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; group_col_length; ++i) &#123;</span><br><span class=\"line\">        pruned_columns.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(i));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> idx : used_col_idxs) &#123; <span class=\"comment\">// Maybe optimized to binary, upper_bound.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt;= group_col_length) &#123;  <span class=\"comment\">// idx &gt;= group_col_length means it&#x27;s aggr.</span></span><br><span class=\"line\">          <span class=\"keyword\">auto</span> aggr_expr = child_aggregation_plan-&gt;aggregates_[idx - group_col_length];</span><br><span class=\"line\">          <span class=\"keyword\">auto</span> aggr_type = child_aggregation_plan-&gt;agg_types_[idx - group_col_length];</span><br><span class=\"line\">          std::string aggr_pair = aggr_expr-&gt;<span class=\"built_in\">ToString</span>() + std::<span class=\"built_in\">to_string</span>(<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(aggr_type));</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (exist_expr.<span class=\"built_in\">count</span>(aggr_pair) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Not exist yet, add to pruned lists.</span></span><br><span class=\"line\">            pruned_aggregates.<span class=\"built_in\">push_back</span>(aggr_expr);</span><br><span class=\"line\">            pruned_agg_types.<span class=\"built_in\">push_back</span>(aggr_type);</span><br><span class=\"line\">            pruned_columns.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(idx));</span><br><span class=\"line\">            exist_expr[aggr_pair] = pruned_columns.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Has existed, add to re_direct map.</span></span><br><span class=\"line\">            re_direct[idx] = exist_expr.<span class=\"built_in\">find</span>(aggr_pair)-&gt;second;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Make new optimized node child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> optimized_aggr = std::<span class=\"built_in\">make_shared</span>&lt;AggregationPlanNode&gt;(</span><br><span class=\"line\">          std::<span class=\"built_in\">make_shared</span>&lt;Schema&gt;(pruned_columns), child_aggregation_plan-&gt;children_[<span class=\"number\">0</span>], </span><br><span class=\"line\">          child_aggregation_plan-&gt;group_bys_, pruned_aggregates, pruned_agg_types);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Modified parent node schema and expr.</span></span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_exprs;</span><br><span class=\"line\">      pruned_exprs.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">int</span>&gt; idx_map = <span class=\"built_in\">RearrangeColIdxs</span>(re_direct, used_col_idxs);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        pruned_exprs.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">PrunedProjectionExpression</span>(expr, idx_map));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      optimized_plan = std::<span class=\"built_in\">make_shared</span>&lt;ProjectionPlanNode&gt;(projection_plan-&gt;output_schema_, pruned_exprs, optimized_aggr);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> optimized_plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(&#123;<span class=\"built_in\">OptimizeColumnPruning</span>(optimized_plan-&gt;children_[<span class=\"number\">0</span>])&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::SeqScan || optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::MockScan ||</span><br><span class=\"line\">      optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::IndexScan) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; new_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    new_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeColumnPruning</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(new_children));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::RearrangeColIdxs</span><span class=\"params\">(std::unordered_map&lt;<span class=\"type\">uint32_t</span>, <span class=\"type\">uint32_t</span>&gt; &amp;re_direct, std::vector&lt;<span class=\"type\">uint32_t</span>&gt; &amp;used_col_idxs)</span> </span></span><br><span class=\"line\"><span class=\"function\">    -&gt; std::vector&lt;<span class=\"type\">int</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Initialize the result map and the del array</span></span><br><span class=\"line\">  <span class=\"type\">int</span> max_col_idx = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(used_col_idxs.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">  <span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">col_idx_map</span><span class=\"params\">(max_col_idx + <span class=\"number\">1</span>, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">del</span><span class=\"params\">(max_col_idx + <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Cache the result of std::lower_bound for each i</span></span><br><span class=\"line\">  <span class=\"function\">std::vector&lt;<span class=\"type\">uint32_t</span>&gt; <span class=\"title\">idx_map</span><span class=\"params\">(max_col_idx + <span class=\"number\">1</span>, used_col_idxs.size())</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= max_col_idx; ++i) &#123;</span><br><span class=\"line\">    idx_map[i] = std::<span class=\"built_in\">find</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>(), i) - used_col_idxs.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// First pass: Fill col_idx_map and update del</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= max_col_idx; ++i) &#123; <span class=\"comment\">// 11</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> idx = idx_map[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; used_col_idxs.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (re_direct.<span class=\"built_in\">count</span>(i)) &#123;</span><br><span class=\"line\">        col_idx_map[i] = re_direct[i];</span><br><span class=\"line\">        del[idx + <span class=\"number\">1</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// When it&#x27;s not in re_direct.</span></span><br><span class=\"line\">        col_idx_map[i] = idx;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Compute cumulative del values</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">1</span>; i &lt; del.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">    del[i] += del[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Final adjustment for col_idx_map</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= max_col_idx; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> idx = idx_map[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (col_idx_map[i] != <span class=\"number\">-1</span> &amp;&amp; !re_direct.<span class=\"built_in\">count</span>(idx)) &#123;</span><br><span class=\"line\">      col_idx_map[i] += del[col_idx_map[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;re_direct:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printUnorderedMap(re_direct);</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;idx_map:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printVector(idx_map);</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;del:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printVector(del);</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;used_col_idxs:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printVector(used_col_idxs);</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;col_idx_map:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printVector(col_idx_map);</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> col_idx_map;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ä¼˜åŒ–åï¼š</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;, &quot;((#0.1+#0.1)+#0.2)&quot;] &#125; </span><br><span class=\"line\">| (__subquery#0.t7.v:INTEGER, __subquery#0.d1:INTEGER, __subquery#0.d2:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">  Agg &#123; types=[&quot;max&quot;, &quot;max&quot;], aggregates=[&quot;#0.1&quot;, &quot;#0.2&quot;], group_by=[&quot;#0.0&quot;] &#125; </span><br><span class=\"line\">  | (t7.v:INTEGER, agg#0:INTEGER, agg#10:INTEGER)</span><br><span class=\"line\">  </span><br><span class=\"line\">    NestedLoopJoin &#123; type=Left, predicate=(#0.0&lt;#1.0) &#125; </span><br><span class=\"line\">    | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER, __subquery#1.t8.v4:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">      SeqScan &#123; table=t7 &#125; | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER)</span><br><span class=\"line\">      </span><br><span class=\"line\">      Values &#123; rows=0 &#125; | (__subquery#1.t8.v4:INTEGER)</span><br></pre></td></tr></table></figure>\n<p>å¯è§aggråªè®¡ç®—äº†ä¸¤ä¸ªmaxã€‚</p>\n<p>ç°åœ¨q3ç”¨æ—¶å¯ä»¥è¾¾åˆ°700å¤šï¼Œå¹¶ä¸”å…¶ä»–æµ‹è¯•ä¹Ÿéƒ½å¯ä»¥é€šè¿‡ã€‚</p>\n<h1 id=\"åè®°\"><a href=\"#åè®°\" class=\"headerlink\" title=\"åè®°\"></a>åè®°</h1><p>ç”±äºç»™çš„åŸºç¡€æµ‹è¯•å¤ªä¸å…¨é¢äº†ï¼Œå¯¼è‡´æˆ‘è‡ªå·±åˆå†™äº†ä¸€ç‚¹ï¼Œä½†ä»ç„¶ä¸å…¨é¢ã€‚æ‰€ä»¥<strong>å®é™…ä¸Šæˆ‘çš„ä»£ç è‚¯å®šè¿˜æœ‰bug</strong>ï¼Œåªæ˜¯è¿˜æ²¡æ‰¾åˆ°ä¸”ä¸å½±å“çº¿ä¸Šæµ‹è¯•ã€‚æƒ³ç”¨çº¿ä¸Šæµ‹è¯•å°±å¿…é¡»è¦éµå¾ªä¸€äº›ä»£ç æ ¼å¼ï¼Œæ¯”å¦‚ä¸èƒ½æ–°å¢æ–‡ä»¶ï¼ŒæŸäº›å‡½æ•°åªèƒ½å†™åœ¨ç‰¹å®šæ–‡ä»¶ï¼Œå¤§éƒ¨åˆ†åˆå§‹ä»£ç ä¸èƒ½è‡ªå·±ä¿®æ”¹â€¦è¿™äº›ä¸œè¥¿å¾ˆå¤§åœ°é™åˆ¶äº†å‘æŒ¥ï¼ŒçœŸè¯šå¸Œæœ›ä»¥åèƒ½æ”¹è¿›ä¸€ä¸‹ï¼Œç»™æˆ‘ä»¬æ›´å¤šè‡ªç”±åº¦ï¼Œè‡³å°‘èƒ½æ–°å¢æ–‡ä»¶å§ã€‚ã€‚ã€‚</p>\n<p>ç›®å‰ä¸‰ä¸ªleaderboard testæ€»åˆ†æ’åè¿›äº†å‰åï¼Œè€Œäº‹å®ä¸Š23fallä¹Ÿæ²¡æœ‰å¤šå°‘äººçœŸæ­£å®Œæˆäº†project 3 çš„å…¨éƒ¨leaderboardéƒ¨åˆ†ã€‚æ‰€è°“çš„cmu15445çƒ‚å¤§è¡—ï¼Œå…¶å®ç¡®å®æ˜¯ä¸ªè°è¨€ã€‚äº‹å®ä¸Š23fallçš„project 3 leaderboardåšå®Œçš„åªæœ‰ä¸åˆ°20ä¸ªäººï¼Œæ›´åˆ«è¯´project 4äº†ã€‚</p>\n<p><strong>æˆ‘è®¤ä¸ºproject 3æ˜¯æœ€é‡è¦çš„ä¸€ä¸ªproject</strong>ã€‚åšè¿‡å‰ä¸¤ä¸ªprojectçš„éƒ½çŸ¥é“ï¼Œproject 1ã€2 å’Œæ•°æ®åº“ç»“æ„çœŸæ²¡å•¥å¤ªå¤§å…³ç³»ã€‚æ‰€ä»¥å½“æˆ‘åšå®Œ1ã€2çš„æ—¶å€™ï¼Œå¯¹æ•°æ®åº“å…·ä½“ç»“æ„æ˜¯å‡ ä¹æ²¡æœ‰è¿›ä¸€æ­¥äº†è§£ã€‚è€Œproject 3 æ‰æ˜¯çœŸæ­£æ·±å…¥Bustubæ‰§è¡Œè¿‡ç¨‹ï¼Œæˆ‘åšå®Œ3åæ‰å¯¹æ•°æ®åº“å„ä¸ªç»„ä»¶æœ‰äº†ä¸€ä¸ªçœŸæ­£ç›´è§‚çš„è®¤è¯†ã€‚éå¸¸æ¨èè‡ªå·±è®¤çœŸå®Œæˆè¿™ä¸ªprojectã€‚</p>\n<p>è´´å‡ºæ¥çš„ä»£ç è·Ÿä¸€å¨ç­”è¾©ä¸€æ ·ï¼Œåç»­æˆ‘å¯¹ä»£ç è¿›è¡Œäº†ä¸€äº›é‡æ„ï¼Œä½†ç°åœ¨çœŸæ˜¯ç´¯æ­»äº†ï¼Œå†™ä¸åŠ¨äº†ã€‚ä½†è¯è¯´èµ·æ¥ï¼Œè¿™ä¸€å¨ä¹Ÿè®©è¯»è€…é˜…è¯»èµ·æ¥æ›´å›°éš¾ï¼Œä¹Ÿç®—é—´æ¥ä¿æŠ¤äº†è¯¾ç¨‹æ— æ³•è¢«æŠ„è¢­ã€‚ã€‚ã€‚</p>\n","categories":["æ•°æ®åº“"],"tags":["æ•°æ®åº“","Bustub"]}]