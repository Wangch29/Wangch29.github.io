[{"title":"Bustub project 3 ä¼˜åŒ–","url":"/2024/12/08/Bustub/project3-leaderboard/","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# å‰è¨€\n\nè¿™æ˜¯ä¸€ä¸ªå…³äºæˆ‘è‡ªå·±çš„cmu15-445 project 3 leaderboardéƒ¨åˆ†çš„æ”»ç•¥ï¼Œä¸ä¼šæ¶‰åŠå…¶å‰é¢åŸºç¡€å®ç°éƒ¨åˆ†ã€‚æœ€ç»ˆæ•ˆæœä¸‰ä¸ªéƒ¨åˆ†å¹³å‡ç”¨æ—¶2000ä»¥å†…ï¼Œè¿›äº†æ’è¡Œæ¦œå‰åã€‚\n\n![](https://i-blog.csdnimg.cn/direct/059ce9aa4865460797af7c48176abc08.png#pic_center)\nå¼•è‡ª[joey-wang](https://www.cnblogs.com/joey-wang/p/17351258.html)\n\n# Query 1: TopNPerGroupPlan\n\næ ¹æ®ä¾‹å­ï¼š\n\n```sql\nCREATE TABLE t1(x INT, y INT, z INT);\nSELECT x, y FROM (\n  SELECT x, y, rank() OVER (partition by x order by y) as rank\n  FROM t1\n) WHERE rank <= 3;\n```\n\né¦–å…ˆå¯ä»¥é€šè¿‡Bustub shell é‡Œçš„ explain å¾—å…¶ç›®å‰çš„ plan treeï¼Œæ¥åˆ†æä¸€ä¸‹æ‰§è¡Œè¿‡ç¨‹:\n\n```\n=== OPTIMIZER ===\nProjection { exprs=[\"#0.0\", \"#0.1\"] }\n  Filter { predicate=(#0.2<=3) }\n    WindowFunc {\n      columns=#0.0, #0.1, placeholder, ,\n      window_functions={\n        2=>{ function_arg=1, type=rank, partition_by=[\"#0.0\"], order_by=[(\"Default\", \"#0.1\")] }\n      }\n    }\n      SeqScan { table=t1 }\n```\n\nå¯çœ‹å‡ºå…¶æœ‰å››ä¸ªplan nodeï¼Œæ‰§è¡Œé¡ºåºå¦‚ä¸‹ï¼š\n```\nSeqscan -> WindowFunc -> Filter -> Projection\n```\n\nå½“æ»¡è¶³Projection <-Filter <- WindowFuncé¡ºåºï¼Œä¸”projectionå°†windowFuncäº§ç”Ÿçš„rankåˆ—æ¸…é™¤æ—¶ï¼Œå®ƒä»¬ä¸‰ä¸ªnodeå¯ä»¥åˆå¹¶æˆä¸€ä¸ªTopNPerGroupPlanï¼Œæ‰«æåç›´æ¥è¿”å›æ¯ä¸ªgroupæ’åå‰Nçš„tupleï¼Œå³ï¼š\n```\nSeqscan -> TopNPerGroupPlan\n```\nå³å¯åœ¨optimizer.hæ–°å¢ä¸€ä¸ªä¼˜åŒ–patternï¼š\n\n```cpp\nauto OptimizeProjectionFilterWindowAsTopGroupN(const AbstractPlanNodeRef &plan) -> AbstractPlanNodeRef;\n```\nä½ ä¼šå‘ç°åŸæœ¬bustubè‡ªå¸¦çš„ä¼˜åŒ–methodå®ç°éƒ½æ˜¯åœ¨ä¸€ä¸ªæ–°çš„.cppæ–‡ä»¶ä¸­ï¼Œä¸ºäº†ç»Ÿä¸€æ ¼å¼ä½ è‡ªç„¶ä¼šæƒ³åˆ°æ–°åˆ›å»ºä¸€ä¸ªOptimizeProjectionFilterWindowAsTopGroupN.cppæ¥å®ç°è¯¥å‡½æ•°ï¼Œå†åŠ å…¥cmakelistsé‡Œã€‚ä½†äº‹ä¸æ„¿è¿ï¼Œç”±äºgradescopeçš„é™åˆ¶ï¼Œå¦‚æœä½ æƒ³çº¿ä¸Šæµ‹è¯•ï¼Œå°±ä¸èƒ½è‡ªå·±æ–°å»ºæ–‡ä»¶ï¼Œè€Œè¦åœ¨é¡¹ç›®æŒ‡å®šoptimizer_custom_rules.cppé‡Œå®ç°ã€‚è¿™ç‚¹ä¼šè®©optimizer_custom_rules.cppå¾€åå˜çš„å¾ˆè‡ƒè‚¿ï¼Œå¸Œæœ›è¯¾ç¨‹ä»¥åèƒ½æ”¹è¿›è¿™ä¸€ç‚¹å§ã€‚ã€‚ã€‚\n\nä¸»è¦æ€è·¯æ˜¯åˆ©ç”¨ä¸€ä¸ªå¯ä»¥ä¿ç•™å¤šä¸ªtuple çš„ç‰¹æ®Špriority queueæ¥ä¸ºæ¯ä¸ªç»„ä¿ç•™top Nä¸ªtupleã€‚æ³¨æ„å¦‚æœæœ‰ç›¸ç­‰çš„tupleï¼Œéœ€è¦åŒæ—¶ä¿ç•™ï¼Œä¾‹å­å¯è§p3.leaderboard_test_q1_windowã€‚è¿˜è¦ç”¨ä¸€ä¸ªhashmap æ¥åˆ†ç»„ã€‚è¿‡ç¨‹å°±æ˜¯ï¼šå…ˆæ‹¿åˆ°ä¸€ä¸ªtupleï¼Œç„¶åè·å¾—å…¶groupå€¼ï¼Œåˆ©ç”¨groupå€¼åškeyåœ¨ä¸€ä¸ª**hashmap**ä¸­æ‰¾åˆ°å…¶æ‰€åœ¨groupå¯¹åº”çš„priority queueï¼Œç„¶åæ’å…¥ã€‚è¿™æ—¶å€™åªéœ€è¦**è‡ªå®šä¹‰ä¸€ä¸‹è¿™ä¸ªpriority queueï¼Œè®©å…¶è‡ªåŠ¨ä¿å­˜å‰nä¸ªtupleå°±å¯ä»¥äº†ã€‚**\n\nå¯¹äºOptimizeProjectionFilterWindowAsTopGroupNï¼Œåˆ™æ˜¯ä¾æ¬¡æŸ¥çœ‹ä¸‰å±‚nodeplanï¼Œå¦‚æœæ»¡è¶³â€œ***Projection <-Filter <- WindowFuncé¡ºåºï¼Œä¸”projectionå°†windowFuncäº§ç”Ÿçš„rankåˆ—æ¸…é™¤æ—¶***â€ï¼Œå³å¯ä¼˜åŒ–æˆTopNPerGroup nodeã€‚å¯ä»¥åˆ©ç”¨shellä¸­çš„explain (o)è¯­å¥æ¥æŸ¥çœ‹ä¼˜åŒ–æ˜¯å¦æˆåŠŸã€‚\n\nå…·ä½“å®ç°å¦‚ä¸‹ï¼š\n```cpp\nauto Optimizer::OptimizeProjectionFilterWindowAsTopGroupN(const AbstractPlanNodeRef &plan) -> AbstractPlanNodeRef {\n  std::vector<AbstractPlanNodeRef> optimized_children{};\n  for (const auto &child : plan->children_) {\n    optimized_children.emplace_back(OptimizeProjectionFilterWindowAsTopGroupN(child));\n  }\n  auto optimized_plan = plan->CloneWithChildren(std::move(optimized_children));\n\n  // First node is Projection.\n  if (optimized_plan->GetType() == PlanType::Projection) {\n    const auto &projection_plan = dynamic_cast<const ProjectionPlanNode &>(*optimized_plan);\n    auto &first_child = projection_plan.GetChildren().at(0);\n    // Second node is filter.\n    if (first_child->GetType() == PlanType::Filter) {\n      const auto &filter_child = dynamic_cast<const FilterPlanNode &>(*first_child);\n      // auto filter_logic_expr = dynamic_cast<const LogicExpression&>(filter_child.predicate_);\n      auto &second_child = filter_child.GetChildren().at(0);\n      // Third node is window.\n      if (second_child->GetType() == PlanType::Window) {\n        const auto &window_child = dynamic_cast<const WindowFunctionPlanNode &>(*second_child);\n        // Try to find Rank's col index.\n        int rank_idx = -1;\n        std::string rank_name;\n        for (size_t col = 0; col < window_child.columns_.size(); ++col) {\n          if (window_child.window_functions_.find(rank_idx) != window_child.window_functions_.end()) {\n            // Is a window function\n            if (window_child.window_functions_.at(rank_idx).type_ == WindowFunctionType::Rank) {\n              rank_idx = col;\n              rank_name = window_child.OutputSchema().GetColumn(rank_idx).GetName();\n              goto OptimizeProjectionFilterWindowAsTopGroupN_END;;\n            }\n          }\n        }\n        // If we find Rank, we can continue to check if it stays after projection.\n        if (rank_idx != -1) {\n          const auto &projection_schema = projection_plan.OutputSchema();\n          for (auto &column : projection_schema.GetColumns()) {\n            if (column.GetName() == rank_name) {  // Find the rank line\n              goto OptimizeProjectionFilterWindowAsTopGroupN_END;\n            }\n          }\n        }\n        // Projection removed RANK, we can optimize it to TopGroupN node.\n        // Find group_bys\n        const std::vector<AbstractExpressionRef> &group_by =\n            window_child.window_functions_.begin()->second.partition_by_;\n        // Find order by\n        const std::vector<std::pair<OrderByType, AbstractExpressionRef>> &order_by =\n            window_child.window_functions_.begin()->second.order_by_;\n        // Find top n;\n        auto value_expr = dynamic_cast<const ConstantValueExpression &>(*filter_child.predicate_->GetChildAt(1));\n        // auto value_expr = dynamic_cast<const ConstantValueExpression &>(*maybe_value_expr);\n        int n = value_expr.val_.CastAs(TypeId::INTEGER).GetAs<int>();\n        return std::make_shared<TopNPerGroupPlanNode>(projection_plan.output_schema_, window_child.children_.at(0),\n                                                      group_by, order_by, n);\n      }\n    }\n  }\n\nOptimizeProjectionFilterWindowAsTopGroupN_END:\n  return optimized_plan;\n}\n```\nåœ¨topn_per_group_executor.cppï¼š\n```cpp\nvoid TopNPerGroupExecutor::Init() {\n  child_executor_->Init();\n  partition_top_n_.clear();\n  \n  size_t top_n = plan_->n_;\n  auto group_by = plan_->GetGroupBy();\n  CompareTuple comparator(&plan_->GetOrderBy(), &child_executor_->GetOutputSchema());\n\n  // Use a priority queue to store the top N tuples for each group.\n  Tuple tuple;\n  RID rid;\n  while (child_executor_->Next(&tuple, &rid)) {   // nlogn\n    AggregateKey group_by_key = ConstructGroupByTuple(tuple, group_by);\n    auto it = partition_top_n_.find(group_by_key);\n    if (partition_top_n_.find(group_by_key) == partition_top_n_.end()) {\n      it = partition_top_n_.emplace(group_by_key, TopNTuplePriorityQueue(top_n, comparator)).first;\n    }\n    it->second.Push(tuple);\n  }\n\n  iter_ = partition_top_n_.begin();\n}\n\nauto TopNPerGroupExecutor::Next(Tuple *tuple, RID *rid) -> bool {\n  if (iter_ != partition_top_n_.end()) {\n    if (iter_->second.Empty()) {\n      // Move to the next pq, and erase current pq.\n      iter_ = partition_top_n_.erase(iter_);\n      return Next(tuple, rid);\n    }\n    *tuple = iter_->second.Pop();\n    *rid = tuple->GetRid();\n    return true;\n  }\n  return false;\n}\n```\nè‡ªå®šä¹‰ç‰ˆpriority queueï¼š\n```cpp\n  class TopNTuplePriorityQueue {\n   public:\n    explicit TopNTuplePriorityQueue(std::size_t n, CompareTuple comparator)\n        : n_(n), pq_(comparator), freq_map_(comparator) {}\n\n    void Push(const Tuple &tuple) {\n      pq_.push(tuple);\n      freq_map_[tuple] += 1;\n      MaintainSize();\n    }\n\n    auto Pop() -> Tuple {\n      if (pq_.empty()) [[unlikely]] {\n        throw std::runtime_error(\"TopNTuplePriorityQueue is empty\");\n      }\n      Tuple top_tuple = pq_.top();\n      pq_.pop();\n      return top_tuple;\n    }\n\n    auto Empty() -> bool { return pq_.empty(); }\n\n   private:\n    std::size_t n_;\n    std::priority_queue<Tuple, std::vector<Tuple>, CompareTuple> pq_;\n    std::map<Tuple, size_t, CompareTuple> freq_map_;\n\n    void MaintainSize() {\n      while (pq_.size() > n_) {\n        // If removing top elements will lead to underflow, break;\n        if (pq_.size() - freq_map_[pq_.top()] < n_) {\n          break;\n        }\n        // Remove top tuples.\n        while (freq_map_[pq_.top()] > 1) {\n          freq_map_[pq_.top()] -= 1;\n          pq_.pop();\n        }\n        freq_map_.erase(pq_.top());\n        pq_.pop();\n      }\n    }\n  };\n```\n\nåœ¨top_n_per_group.hä¸­çš„TupleComparatorå’Œå…¶ä»–ä¸€äº›ä¸œè¥¿å°±ç•™ç»™è¯»è€…æ€è€ƒï¼Œä¸å†™å‡ºäº†ï¼Œå…·ä½“æ€è·¯æˆ‘å·²ç»åœ¨ä¸Šé¢è®²è¿‡äº†ã€‚è€Œè¿™ä¸ªç©æ„çš„è¾“å‡ºä¸éœ€è¦æŒ‰ç…§ä¸€å®šé¡ºåºæ¯”å¦‚å‡åºï¼Œåªéœ€è¦è·å¾—çš„tupleå¯¹å°±è¡Œã€‚\n\nè‡³æ­¤å³å¯é€šè¿‡leaderboard test q1ï¼Œæˆ‘çš„ç”¨æ—¶ç›®å‰æ˜¯7000å¤šï¼Œæ’åå¤šåï¼Œåœ¨åšäº†ä¼˜åŒ–çš„äººä¸­ç®—æ˜¯æ…¢çš„äº†ï¼Œçœ‹æ¥è¿˜æœ‰ä¼˜åŒ–ç©ºé—´ã€‚\n\nåšä¸ªprofilingçœ‹çœ‹ğŸ‘€ï¼š\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/bc28397020ab4437bbce3ac400b42368.png#pic_center)\næˆ‘å‘ç°TopNTuplePriorityQueueä¸­çš„**MaintainSize()**å‡½æ•°æ¯”æˆ‘æƒ³è±¡çš„è€—æ—¶é—´ã€‚MaintainSizeå æ®äº†Pushè¿‡åŠçš„æ—¶é—´ï¼Œè€Œ**freq_map_[]**åˆå æ®äº†MaintainSizeè¿‡åŠçš„æ—¶é—´ï¼Œæ‰€ä»¥ç”¨åŸºäºçº¢é»‘æ ‘çš„mapè¿˜æ˜¯ä¸è¡Œï¼Œå¯ä»¥æŠŠ std::map<Tuple, size_t, CompareTuple> freq_map_ ä¼˜åŒ–æˆ unordered_mapã€‚\n\n```cpp\nvoid MaintainSize() {\n      while (pq_.size() > n_) {\n        // If removing top elements will lead to underflow, break;\n        uint32_t top_tuple_freq = freq_map_[pq_.top()];\n        if (pq_.size() - top_tuple_freq < n_) {\n          break;\n        }\n        // Remove top tuples.\n        freq_map_.erase(pq_.top());\n        for (size_t i = 0; i < top_tuple_freq; ++i) {\n          pq_.pop();\n        }\n      }\n    }\n\n...\n\nstd::unordered_map<Tuple, size_t, TupleHash, TupleEqual> freq_map_;\n```\n\nç„¶åå†æµ‹è¯•ï¼Œå‘ç°å±…ç„¶q1ç”¨æ—¶ç›´æ¥ä»7000å¤šå‡å°‘åˆ°äº†4000å¤šï¼Œå¿«äº†40%å¤šï¼Œæ•ˆæœååˆ†æ˜¾è‘—å•Šã€‚å¯è§profilingå¯¹ä¼˜åŒ–çš„æŒ‡å¯¼è¿˜æ˜¯å¾ˆæœ‰æ•ˆçš„ã€‚\n\nä¼˜åŒ–åå†åšä¸ªprofilingï¼š\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/56f81ad3ada240c29acd9eecd359ed73.png#pic_center)\nå¯è§Push()ç”¨æ—¶å¤§å¹…ç¼©çŸ­ã€‚ä½†leaderboardä¸Šè¿˜æœ‰ç¥äººèƒ½ä¼˜åŒ–åˆ°1000å¤šï¼ŒçœŸä¸çŸ¥æ€ä¹ˆåšåˆ°çš„ã€‚\n# Query 2: Too Many Joins!\n\n## è§£æ\nä¸€åæ¥è‡ª[ä¸¥è¾‰æ‘](https://zh.wikipedia.org/wiki/%E8%8C%83%E5%B0%8F%E5%8B%A4)çš„æ‘æ°‘å†™äº†å¦‚ä¸‹çš„sqlï¼š\n\n```sql\nCREATE TABLE t4(x int, y int);\nCREATE TABLE t5(x int, y int);\nCREATE TABLE t6(x int, y int);\n\nSELECT * FROM t4, t5, t6\n  WHERE (t4.x = t5.x) AND (t5.y = t6.y) AND (t4.y >= 1000000)\n    AND (t4.y < 1500000) AND (t6.x >= 100000) AND (t6.x < 150000);\n```\nå¯è§ä»–å…¶å®æƒ³å§**t4ã€t5 join on x, t5ã€t6 join on y**, ä½†æ˜¯å¹¶æ²¡æœ‰äººä¸ºåœ°åˆ†æ­¥åˆå¹¶ï¼Œè€Œæ˜¯ä¸€è‚¡è„‘åœ°æŠŠæ¡ä»¶å…¨æ”¾åœ¨äº†**where**åé¢ã€‚å¦‚æœæ²¡æœ‰ä¼˜åŒ–ï¼Œå°±å¯¼è‡´è¯¥queryæ‰§è¡Œçš„æ—¶å€™ä¼šæŠŠt4ã€t5ã€t6åšä¸¤ä¸ªç¬›å¡å°”ç§¯ï¼ˆ**Cartesian product**ï¼Œå³æ— æ¡ä»¶çš„joinï¼‰ç”Ÿäº§ä¸€ä¸ªå·¨å¤§çš„tableï¼Œç„¶åéå†è¿™ä¸ªå·¨å¤§çš„tableè¿›è¡Œè¿‡æ»¤ã€‚\n\nå½“ç„¶ï¼Œä½ åœ¨å‰é¢å·²ç»å®ç°äº†åŒ…æ‹¬**hash join**åœ¨å†…çš„éƒ¨åˆ†ä¼˜åŒ–å™¨ï¼Œæ‰€ä»¥å®é™…ä¸Šæ ¹æ®æˆ‘ä¸ªäººå‰é¢çš„å®ç°ï¼Œä¼šå…ˆå¯¹t4ã€t5è¿›è¡Œä¸€ä¸ªåŸºäºhash joinçš„ç¬›å¡å°”ç§¯ï¼Œç„¶åå†å’Œt6è¿›è¡Œä¸€ä¸ªæœ‰æ¡ä»¶çš„hash joinï¼Œæœ€åè¿›è¡Œä¸€ä¸ªè¿‡æ»¤ï¼ˆfilter nodeï¼‰ã€‚\n\nå…·ä½“ç»è¿‡ç”¨explain (o)å¯çœ‹å…¶plan tree:\n\n```\n=== OPTIMIZER ===\nFilter { predicate=(((((#0.0=#0.2)and(#0.1>=1000000))and(#0.1<1500000))and\n(#0.4>=100000))and(#0.4<150000)) } | \n(t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)\n\n  HashJoin { type=Inner, left_key=[\"#0.3\"], right_key=[\"#1.1\"] } | \n  (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)\n  \n    HashJoin { type=Inner, left_key=[], right_key=[] } | \n    (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER)\n    \n      SeqScan { table=t4 } | (t4.x:INTEGER, t4.y:INTEGER)\n      SeqScan { table=t5 } | (t5.x:INTEGER, t5.y:INTEGER)\n    SeqScan { table=t6 } | (t6.x:INTEGER, t6.y:INTEGER)\n```\nè¿™ä¸ªæ ¹æ®æ¯ä¸ªäººä¹‹å‰å¯¹**Optimizer::OptimizeNLJAsHashJoin(**)å®ç°çš„ä¸åŒï¼Œè¿™é‡Œçš„æƒ…å†µä¹Ÿä¼šæœ‰ä¸åŒã€‚\n\n## å…³äºHash Join\n\nè€ŒOptimizeNLJAsHashJoinå…¶å®è¿˜æŒºç¹ççš„ï¼Œæ ¹æ®æˆ‘å¯¹gradescopeä¸Šleaderboardçš„è§‚å¯Ÿï¼Œæœ‰å¾ˆå¤šäººå¯¹è¿™ä¸ªå‡½æ•°çš„å®ç°å…¶å®çš„é”™è¯¯çš„ï¼Œ**åªæ˜¯å› ä¸ºgradescopeä¸Šçš„åŸºç¡€æµ‹è¯•å¹¶ä¸å…¨é¢ï¼Œä»–ä»¬æ‰é€šè¿‡äº†é™¤leaderboardå¤–å…¶ä½™çš„åŸºç¡€æµ‹è¯•**ã€‚è€Œåˆ°äº†leaderboardæµ‹è¯•ï¼Œå°±ä¼šå‡ºç°bugäº†ã€‚\n\næ‰€ä»¥æˆ‘è®²ä¸€ä¸‹æˆ‘çš„hashjoinçš„å®ç°æ€è·¯ï¼šå¤§æ¦‚æ˜¯ç”¨ä¸€ä¸ªé€’å½’éå†NLJ_plan.predicateçš„treeï¼Œå½“å‘ç°**ColumnValueExpression**ä¸”åˆ¤æ–­å¼ä¸ºequalä¸”å…¶å·¦å³å­©å­expressionå‡ä¸ºColumnValueExpressionä¸”GetTupleIdx()åˆ†åˆ—å·¦å³çš„æ—¶å€™ï¼Œå°†å…¶åŠ å…¥hash joinå¹¶ä»åŸexpression treeä¸­åˆ é™¤ã€‚è€Œéå†åå‰©ä¸‹çš„expression treeåˆ™ç”¨äºåˆ›å»ºä¸€ä¸ªfilteræ”¾åœ¨hash join ä¸Šæ–¹ã€‚è€Œä¸”åœ¨ç”Ÿæˆfilterçš„æ—¶å€™è¦è®°å¾—ä¿®æ”¹ColumnValueExpressionçš„col_idxã€‚\n\nä¸¾ä¸ªä¾‹å­ï¼š\n```sql\nSELECT * FROM t4, t5\n WHERE (t4.x = t5.x) AND (t4.x = t4.y) AND (t4.z >= t5.z) AND (t5.x = 100);\n```\nè¿™ä¸ªqueryä¼šè¢«ä¼˜åŒ–æˆï¼š\n```\nFilter: (t4.x = t4.y) AND (t4.z >= t5.z) AND (t5.z = 100)\n         â”‚\n         â””â”€â”€ HashJoin: t4.x = t5.x\n             â”œâ”€â”€ Sequential Scan: t4\n             â””â”€â”€ Sequential Scan: t5\n```\nå››ä¸ªæ¡ä»¶åªæœ‰$t4.x = t5.x$èƒ½è¢«æ”¾å…¥hash join, å› ä¸º$t4.x = t4.y$åªä½œç”¨åœ¨left childï¼Œ $t4.z >= t5.z$ä¸æ˜¯ç­‰å¼è€Œæ˜¯ä¸ç­‰å¼ï¼Œ$t5.x = 100$åªä½œç”¨äºright childä¸”æœ‰ä¸€ä¸ªå¸¸æ•°é¡¹ã€‚æ‰€ä»¥è¿™ä¸‰ä¸ªåˆ¤æ–­éƒ½ä¸Šç§»åˆ°filterã€‚\n\nè€Œè¿˜è¦è€ƒè™‘æ›´å¤æ‚çš„NLJçš„æ¡ä»¶ä¸­logicè¿æ¥è¯ä¸º**OR**çš„æƒ…å†µï¼Œå¦‚:\n```sql\nSELECT * FROM t4, t5\n WHERE (t4.x = t5.x) OR (t4.y = t5.y);\n```\næˆ‘ç›®å‰çš„åšæ³•æ˜¯å¦‚æœå­˜åœ¨ORå°±ç›´æ¥ä¿æŒNLJï¼Œä½†å…¶å®å¯ä»¥è¿™æ ·ä¼˜åŒ–æˆï¼š\n```sql\nSELECT *\nFROM t4, t5\nWHERE t4.x = t5.x\nUNION ALL\nSELECT *\nFROM t4, t5\nWHERE t4.y = t5.y;\n```\næˆ–è€…ç”¨treeè¡¨è¾¾ï¼š\n```\nUnion All\nâ”œâ”€â”€ HashJoin: t4.x = t5.x\nâ”‚   â”œâ”€â”€ Sequential Scan: t4\nâ”‚   â””â”€â”€ Sequential Scan: t5\nâ””â”€â”€ HashJoin: t4.y = t5.y\n    â”œâ”€â”€ Sequential Scan: t4\n    â””â”€â”€ Sequential Scan: t5\n```\nå³å°†ORè¿æ¥çš„éƒ¨åˆ†æ‹†åˆ†æˆä¸¤ä¸ªhash joinï¼Œç„¶åå†Unionèµ·æ¥ã€‚\n\n## ä¼˜åŒ–\n\nå›åˆ°æ­£é¢˜ï¼Œè¿™ä¸ªqueryå°±æ˜¯æ•…æ„è®¾è®¡ä¸€ä¸ªpredicateé›†ä¸­åˆ†å¸ƒåœ¨node treeä¸Šæ–¹ï¼Œä¸»è¦è€ƒå¯Ÿçš„æ˜¯ä¼˜åŒ–å™¨å¯¹predicate pushdownçš„èƒ½åŠ›ã€‚\n\n```\nFilter { predicate=(((((#0.0=#0.2)and(#0.1>=1000000))and(#0.1<1500000))and\n(#0.4>=100000))and(#0.4<150000)) } | \n(t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)\n\n  HashJoin { type=Inner, left_key=[\"#0.3\"], right_key=[\"#1.1\"] } | \n  (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)\n  \n    HashJoin { type=Inner, left_key=[], right_key=[] } | \n    (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER)\n    \n      SeqScan { table=t4 } | (t4.x:INTEGER, t4.y:INTEGER)\n      SeqScan { table=t5 } | (t5.x:INTEGER, t5.y:INTEGER)\n    SeqScan { table=t6 } | (t6.x:INTEGER, t6.y:INTEGER)\n```\n\n```\n# Query Plan Node Tree\n\nFilter: (t4.y = t5.y) AND (t4.x >= 1000000)) AND (t4.x < 1500000)) \n|\t\t\tAND (t6.x >= 100000)) AND (t6.x < 150000))\nâ”‚\nâ””â”€â”€ HashJoin: t5.y = t6.y\n    â”œâ”€â”€ HashJoin: t4.x = t5.x\n    â”‚   â”œâ”€â”€ Sequential Scan: t4\n    â”‚   â””â”€â”€ Sequential Scan: t5\n    â””â”€â”€ Sequential Scan: t6\n```\nç”»å‡ºplan node tree å¯ä»¥çœ‹å‡ºï¼Œæ ¹æ®æˆ‘ä¹‹å‰çš„å®ç°ï¼Œpredicateéƒ½é£˜åœ¨æœ€ä¸Šæ–¹ï¼Œç°åœ¨è¦åšçš„æ˜¯æŠŠpredicateä¸‹æ¨ï¼Œå…¶åœ¨åç»­ä¼˜åŒ–å‡½æ•°çš„ä½œç”¨ä¸‹å¯ä»¥ä¸**NLJã€seq_scan**ç­‰nodeåˆå¹¶ã€‚\n\nåœ¨optimizer.hæ–°å¢ä¼˜åŒ–å‡½æ•°ï¼š\n```cpp\nauto OptimizePredicatePushdown(const AbstractPlanNodeRef &plan) -> AbstractPlanNodeRef;\n```\nåŒæ ·åœ¨optimizer_custom_rules.cppä¸­å®ç°ï¼š\n```cpp\nauto Optimizer::OptimizePredicatePushdown(const AbstractPlanNodeRef &plan) -> AbstractPlanNodeRef {\n  std::vector<AbstractPlanNodeRef> optimized_children{};\n  for (const auto &child : plan->children_) {\n    optimized_children.emplace_back(OptimizePredicatePushdown(child));\n  }\n  auto optimized_plan = plan->CloneWithChildren(std::move(optimized_children));\n\n  // Plan Should be a filter node.\n  if (optimized_plan->GetType() == PlanType::Filter) {\n    auto filter_plan = dynamic_cast<FilterPlanNode *>(optimized_plan.get());\n    std::vector<std::shared_ptr<ComparisonExpression>> pushdowns;\n    filter_plan->predicate_ = ParsePredicate(filter_plan->predicate_, filter_plan->OutputSchema(), pushdowns);\n    // No predicate could be pushed down, simply return.\n    if (pushdowns.empty()) {\n      return optimized_plan;\n    }\n    // All predicate could be pushed down, remove the filter node.\n    if (filter_plan->predicate_ == nullptr) {\n      return Pushdown(filter_plan->children_[0], pushdowns);\n    }\n    // Part of predicate could be pushed down.\n    return filter_plan->CloneWithChildren({Pushdown(filter_plan->children_[0], pushdowns)});\n  }\n\n  return optimized_plan;\n}\n```\nè¿˜æœ‰å‡ ä¸ªhelper methodæˆ‘å°±ä¸æ”¾å‡ºäº†ï¼Œè¯´ä¸€ä¸‹æ€è·¯ï¼š\n\né¦–å…ˆè¦è·å–predicateï¼Œ è€Œpredicateå­˜åœ¨filter nodeä¸­ï¼Œæ‰€ä»¥å½“é‡åˆ°ä¸€ä¸ªfilter nodeï¼Œç”¨**ParsePredicate()** æ¥è·å–predicateã€‚è¿™ä¸ªå‡½æ•°è¾“å…¥å€¼**filter_plan->predicate_**æ˜¯ä¸€ä¸ªtreeï¼Œé€’å½’éå†å¤„ç†è¿™ä¸ªtreeï¼Œå°†ç”¨**AND**è¿æ¥çš„**ComparisonExpression**åŠ å…¥**pushdowns**è¿™ä¸ªvectorï¼Œé‡åˆ°ORåˆ™åœæ­¢ç›´æ¥ä¿æŒåŸæ ·è¿”å›ã€‚åŠ å…¥pushdownsçš„expressionè¦ä»åŸæ ‘ä¸­å‰”é™¤ã€‚\n\nè¿™æ ·å°±è·å¾—äº†éœ€è¦ä¸‹æ¨çš„predicatesï¼Œå°†è¿™äº›predicateså’Œå­èŠ‚ç‚¹æ”¾å…¥ä¸‹æ¨å‡½æ•°**Pushdown()**ã€‚Pushdownä¸­å¯¹é‡åˆ°çš„å„ç§ç±»å‹çš„plan nodeåˆ†ç±»å¤„ç†ï¼Œæœ‰çš„å¯ä»¥ç›´æ¥è·³è¿‡ï¼Œæœ‰çš„ä¼šé˜»å¡ä¸‹æ¨ï¼Œæœ‰çš„ä¼šä½¿ä¸‹æ¨åˆ†å‰(join node)ã€‚ ç±»ä¼¼ï¼š\n```cpp\nauto Optimizer::Pushdown(const AbstractPlanNodeRef &plan,\n                         std::vector<std::shared_ptr<ComparisonExpression>> &pushdowns) -> AbstractPlanNodeRef {\n  if (pushdowns.empty()) {\n    return plan;\n  }\n  // Check if plan is Filter.\n  switch (plan->GetType()) {\n    case PlanType::NestedLoopJoin: {\n      TODO: ... ... \n      return optimized_plan;\n    }\n\n    // Skip these nodes.\n    case PlanType::Filter:\n    case PlanType::Limit:\n    case PlanType::Sort: {\n      return plan->CloneWithChildren(std::vector<AbstractPlanNodeRef>{Pushdown(plan->GetChildAt(0), pushdowns)});\n    }\n\n    // Block pushdown, generate a filter plan above it.\n    case PlanType::SeqScan:\n    case PlanType::MockScan:\n    case PlanType::Aggregation:\n    case PlanType::Window:\n    case PlanType::Delete:\n    case PlanType::Update:\n    case PlanType::Insert:\n    case PlanType::Projection:\n    case PlanType::InitCheck: {\n      return std::make_shared<FilterPlanNode>(plan->output_schema_, ConcatencateComparisonAnd(pushdowns), plan);\n    }\n\n    // Advanced planNode, they should be generated latter.\n    case PlanType::TopNPerGroup:\n    case PlanType::TopN:\n    case PlanType::HashJoin:\n    case PlanType::NestedIndexJoin: {\n      UNREACHABLE(\"This kind of node should not appear in pushdown. They should be made after pushdown.\");\n    }\n\n    default: {\n      UNREACHABLE(\"Not supported planNode type.\");\n    }\n  }\n}\n\n```\nå…¶ä¸­æœ€å¤æ‚çš„å°±æ˜¯é‡åˆ°**NestedLoopJoin**ï¼Œè®°å¾—è¦ä¿®æ”¹åƒå³å­æ ‘ç»§ç»­ä¸‹æ¨çš„predicatesçš„**col_idx**ã€‚\n\nå½“æ¨åˆ°å¯ä»¥åˆå¹¶çš„èŠ‚ç‚¹ï¼Œå¦‚seq_scanã€NLJçš„æ—¶å€™ï¼Œåªéœ€è¦åœ¨å…¶ä¸Šæ–¹å»ºä¸€ä¸ªfilter nodeï¼Œå› ä¸ºåç»­å…¶ä»–çš„ä¼˜åŒ–å‡½æ•°ä¼šå¸®ä½ åˆå¹¶ã€‚è€Œ**OptimizePredicatePushdown**æˆ‘æ˜¯æ”¾åœ¨äº†**Optimizer::OptimizeCustom**ä¸­çš„é å‰ä½ç½®ï¼Œè¿™æ ·å¯ä»¥å…ˆä¸‹æ¨ï¼Œå†åˆå¹¶ï¼Œä¼˜åŒ–è°ƒç†æ¸…æ™°ï¼Œå……åˆ†åˆ©ç”¨å·²ç»å†™å¥½çš„å…¶ä»–ä¼˜åŒ–å‡½æ•°ã€‚\n\nå®ç°ä¸‹æ¨åï¼š\n```\n=== OPTIMIZER ===\nHashJoin { type=Inner, left_key=[\"#0.3\"], right_key=[\"#1.1\"] } \n| (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)\n\nHashJoin { type=Inner, left_key=[\"#0.0\"], right_key=[\"#1.0\"] } \n| (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER)\n\nSeqScan { table=t4, filter=((#0.1<1500000)and(#0.1>=1000000)) } \n| (t4.x:INTEGER, t4.y:INTEGER)\n   \nSeqScan { table=t5 } | (t5.x:INTEGER, t5.y:INTEGER)\n    \nSeqScan { table=t6, filter=((#0.0<150000)and(#0.0>=100000)) }\n| (t6.x:INTEGER, t6.y:INTEGER)\n```\n```\nHashJoin: t4.y = t6.y\n| Output: (t4.x, t4.y, t5.x, t5.y, t6.x, t6.y)\nâ”‚\nâ”œâ”€â”€ HashJoin: t4.x = t5.x\nâ”‚   | Output: (t4.x, t4.y, t5.x, t5.y)\nâ”‚   â”‚\nâ”‚   â”œâ”€â”€ SeqScan: table=t4\nâ”‚   â”‚   | Filter: (t4.y >= 1000000) AND (t4.y < 1500000)\nâ”‚   â”‚   | Output: (t4.x, t4.y)\nâ”‚   â”‚\nâ”‚   â””â”€â”€ SeqScan: table=t5\nâ”‚       | No Filter\nâ”‚       | Output: (t5.x, t5.y)\nâ”‚\nâ””â”€â”€ SeqScan: table=t6\n    | Filter: (t6.x >= 100000) AND (t6.x < 150000)\n    | Output: (t6.x, t6.y)\n```\nå¯çœ‹åˆ°è°“è¯è¢«ä¸‹æ¨åˆ°åˆé€‚çš„åœ°æ–¹äº†ã€‚\n\næ­¤æ—¶leaderboard q2ç”¨æ—¶1900å¤šï¼Œæ’åç¬¬å…«ã€‚\n\n## è¿›ä¸€æ­¥ä¼˜åŒ–æƒ³æ³•\n1. **Joiné‡æ’ join reorder**ã€‚å…ˆä¼°ç®—è¡¨çš„å¤§å°ï¼Œç„¶åé‡æ’è¿æ¥é¡ºåºï¼Œå…ˆjoinå°è¡¨åjoinå¤§è¡¨ã€‚\n2. **å®ç°Hash joinçš„æ¯”è¾ƒå·¦å³è¡¨**ã€‚ä¼°ç®—å·¦å³è¡¨å¤§å°ï¼Œä»è€Œç”¨å°è¡¨æ„é€ hash mapã€‚\n3. **limit/agg ä¸‹æ¨**ã€‚ä½†leaderboard testä¸­æ²¡æœ‰é’ˆå¯¹æ­¤çš„æµ‹è¯•ï¼Œæ‰€ä»¥å®ç°äº†å¯¹æ’åæé«˜æ— ç”¨ã€‚\n4. **queryå¤ç”¨è®¡ç®—ç»“æœ**ã€‚leaderboardæµ‹è¯•é€»è¾‘è²Œä¼¼æ˜¯æŠŠåŒä¸€ä¸ªqueryæ‰§è¡Œ10æ¬¡ï¼Œæ‰€ä»¥å®ç°å‚¨å­˜queryç»“æœå¤ç”¨æœ‰å¯èƒ½å¯ä»¥å¤§å¹…åŠ é€Ÿç¬¬2ï½10æ¬¡queryã€‚\n\n# Query 3: The Mad Data Scientist\nä¸€åè´­ä¹°äº†æ’å¤ªæˆ¿äº§çš„æ•°æ®ç§‘å­¦å®¶æ„è¯†åˆ°è‡ªå·±çš„æ‰€ä½œæ‰€ä¸ºä¹‹åï¼Œå†™ä¸‹äº†è¿™äº›å¥‡æ€ªçš„queryï¼š\n```sql\ncreate table t7(v int, v1 int, v2 int);\ncreate table t8(v4 int);\n\nexplain SELECT v, d1, d2 FROM (\n  SELECT v,\n         MAX(v1) AS d1, MIN(v1), MAX(v2), MIN(v2),\n         MAX(v1) + MIN(v1), MAX(v2) + MIN(v2),\n         MAX(v1) + MAX(v1) + MAX(v2) AS d2\n    FROM t7 LEFT JOIN (SELECT v4 FROM t8 WHERE 1 == 2) ON v < v4\n    GROUP BY v\n);\n```\nå¯ä»¥çœ‹åˆ°æœ‰å¾ˆå¤šå¥‡æ€ªçš„ä¸œè¥¿ï¼Œæ¯”å¦‚å§‹ç»ˆç­‰äºfalseçš„\n```sql\nWHERE 1 == 2\n```\nè¿˜æœ‰è®¡ç®—äº†è¿™äº›æ•°æ®ï¼Œä½†å¹¶æ²¡æœ‰è¾“å‡ºï¼š\n```sql\nMIN(v1), MAX(v2), MIN(v2),\nMAX(v1) + MIN(v1), MAX(v2) + MIN(v2),\n```\nç¬¬ä¸€ä¸ªå§‹ç»ˆç­‰äºfalseçš„è¡¨è¾¾å¼è€ƒå¯Ÿçš„æ˜¯ä¼˜åŒ–å™¨**å¸¸é‡æŠ˜å (constant folding)**èƒ½åŠ›ï¼Œè€Œç¬¬äºŒä¸ªå»é™¤å†—ä½™çš„è®¡ç®—è€ƒå¯Ÿçš„æ˜¯ä¼˜åŒ–å™¨åˆ—**å‰ªæ(Column pruning)**çš„èƒ½åŠ›ã€‚\n\nå…ˆçœ‹çœ‹ä¼˜åŒ–å‰ï¼š\n\n```\n=== OPTIMIZER ===\nProjection { exprs=[\"#0.0\", \"#0.1\", \"#0.7\"] } | (__subquery#0.t7.v:INTEGER, __subquery#0.d1:INTEGER, __subquery#0.d2:INTEGER)\n\n  Projection { exprs=[\"#0.0\", \"#0.1\", \"#0.2\", \"#0.3\", \"#0.4\", \"(#0.5+#0.6)\", \"(#0.7+#0.8)\", \"((#0.9+#0.10)+#0.11)\"] } | (__subquery#0.t7.v:INTEGER, __subquery#0.d1:INTEGER, __subquery#0.__item#2:INTEGER, __subquery#0.__item#3:INTEGER, __subquery#0.__item#4:INTEGER, __subquery#0.__item#5:INTEGER, __subquery#0.__item#6:INTEGER, __subquery#0.d2:INTEGER)\n  \n    Agg { types=[\"max\", \"min\", \"max\", \"min\", \"max\", \"min\", \"max\", \"min\", \"max\", \"max\", \"max\"], \n    aggregates=[\"#0.1\", \"#0.1\", \"#0.2\", \"#0.2\", \"#0.1\", \"#0.1\", \"#0.2\", \"#0.2\", \"#0.1\", \"#0.1\", \"#0.2\"], \n    group_by=[\"#0.0\"] }\n   \t| (t7.v:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER, agg#3:INTEGER, agg#4:INTEGER, agg#5:INTEGER, agg#6:INTEGER, agg#7:INTEGER, agg#8:INTEGER, agg#9:INTEGER, agg#10:INTEGER)\n    \n      Filter { predicate=(#0.0<#0.3) } | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER, __subquery#1.t8.v4:INTEGER)\n      \n        HashJoin { type=Left, left_key=[], right_key=[] } | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER, __subquery#1.t8.v4:INTEGER)\n        \n          SeqScan { table=t7 } | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER)\n          \n          SeqScan { table=t8, filter=(1=2) } | (t8.v4:INTEGER)\n```\n```\nProjection: (__subquery#0.t7.v, __subquery#0.d1, __subquery#0.d2)\nâ”‚\nâ””â”€â”€ Projection: (__subquery#0.t7.v, __subquery#0.d1, __subquery#0.d2, derived columns)\n    â”‚\n    â””â”€â”€ Aggregation: Group by (t7.v), Aggregates: max/min\n        â”‚\n        â””â”€â”€ Filter: (t7.v < __subquery#1.t8.v4)\n            â”‚\n            â””â”€â”€ HashJoin: Left Join (t7, t8)\n                â”‚\n                â”œâ”€â”€ Sequential Scan: t7\n                â”‚\n                â””â”€â”€ Sequential Scan: t8 (filtered: (1=2) )\n```\n\n\n## å¸¸é‡æŠ˜å  Constant Folding\nå¸¸é‡æŠ˜å æŒ‡çš„æ˜¯ä¼˜åŒ–å™¨æå‰å°†å¯ä»¥è®¡ç®—çš„è¡¨è¾¾å¼è®¡ç®—å‡ºç»“æœï¼Œå¦åˆ™æ¯æ¥ä¸€ä¸ªtupleï¼Œè¡¨è¾¾å¼å°±è¦é‡æ–°è®¡ç®—ä¸€æ¬¡ã€‚\n\nåœ¨optimizer.hä¸­å¢åŠ declarationï¼Œå¹¶åœ¨optimizer_custom_rules.cppä¸­å®ç°ï¼š\n```cpp\nauto Optimizer::OptimizeConstantFolding(const AbstractPlanNodeRef &plan) -> AbstractPlanNodeRef {\n  std::vector<AbstractPlanNodeRef> optimized_children{};\n  for (const auto &child : plan->children_) {\n    optimized_children.emplace_back(OptimizeConstantFolding(child));\n  }\n  auto optimized_plan = plan->CloneWithChildren(std::move(optimized_children));\n\n  // For filter, folding its predicate.\n  if (optimized_plan->GetType() == PlanType::Filter) {\n    auto filter_plan = dynamic_cast<FilterPlanNode *>(optimized_plan.get());\n    auto new_predicate = FoldingPredicate(filter_plan->predicate_);\n    // If the new_predicate is constant, \n    // true, return its child; false, return an empty value node.\n    if (auto new_predicate_const = dynamic_cast<const ConstantValueExpression *>(new_predicate.get())) {\n      if (new_predicate_const->Evaluate({}, Schema({})).GetAs<bool>()) {\n        return plan->children_[0];\n      }\n      return std::make_shared<ValuesPlanNode>(plan->output_schema_, std::vector<std::vector<AbstractExpressionRef>>{});\n    }\n    // new_predicate is not a constant, return a new filter.\n    return std::make_shared<FilterPlanNode>(filter_plan->output_schema_, new_predicate, filter_plan->children_[0]);\n  }\n  \n  return optimized_plan;\n}\n```\n\nå®ç°å¸¸é‡æŠ˜å åï¼š\n```\n# Query Execution Plan\n\nProjection: (output columns: #0.0, #0.1, #0.7)\nâ”‚\nâ””â”€â”€ Projection: (output columns: #0.0, #0.1, #0.2, #0.3, #0.4, (#0.5 + #0.6), (#0.7 + #0.8), ((#0.9 + #0.10) + #0.11))\n    â”‚\n    â””â”€â”€ Aggregation: Group By (#0.0), Aggregates (max/min on #0.1, #0.2)\n        â”‚\n        â””â”€â”€ Filter: (#0.0 < #0.3)\n            â”‚\n            â””â”€â”€ HashJoin: Left Join\n                â”‚\n                â”œâ”€â”€ Sequential Scan: t7\n                â”‚\n                â””â”€â”€ Values: (empty set, rows=0)\n```\nå¯è§seq_scan t8 è¢«æŠ˜å æˆç©ºçš„Value nodeäº†ã€‚æ­¤æ—¶å¯ä»¥å¯¹Joinè¿›è¡Œä¼˜åŒ–ï¼Œå¦‚æœå³å­©ä¸ºç©ºï¼Œç›´æ¥è¿”å›å·¦å­©(left join)æˆ–ç›´æ¥è¿”å›false(inner join)ã€‚**ä½†ç›®å‰ä¸å¯ä»¥ç›´æ¥åˆ é™¤Joinï¼Œå› ä¸ºjoinä¹‹åschemaä¼šæ”¹å˜ã€‚**\n\næ­¤æ—¶åªæŠ˜å äº†filteré‡Œçš„expressionsï¼Œè¿™è™½ç„¶å·²ç»è¶³å¤Ÿåº”ä»˜æµ‹è¯•ï¼Œä½†ä½ è¿˜å¯ä»¥å°†å…¶ä½™æœ‰expressionsçš„planéƒ½ç»™æŠ˜å äº†ï¼Œè¿™å°±ä¸è´´å‡ºæ¥äº†ï¼Œç•™ç»™è¯»è€…å®ç°ã€‚\n\n##  åˆ—å‰ªæ ColumnPruning\nå¯ä»¥çœ‹åˆ°å®ç°å¸¸é‡æŠ˜å åçš„æ‰§è¡Œæ ‘ä¸­ï¼Œ\n```\nProjection: (output columns: #0.0, #0.1, #0.7)\n```\næœ€ç»ˆç»“æœåªè¾“å‡º#0.0 #0.1 #0.7ï¼Œä½†aggregateå´è®¡ç®—äº†ä¸€é•¿ä¸²ï¼š\n```\nProjection: (output columns: #0.0, #0.1, #0.2, #0.3, #0.4, (#0.5 + #0.6), (#0.7 + #0.8), ((#0.9 + #0.10) + #0.11)\n```\næ‰€ä»¥å½“Projectionçš„å­èŠ‚ç‚¹ä¸ºProjectionæˆ–è€…Aggregationçš„æ—¶å€™ï¼Œå¯ä»¥å¯¹å­èŠ‚ç‚¹è¿›è¡Œå‰ªæï¼Œé¿å…ä¸éœ€è¦çš„è®¡ç®—å’Œå†…å­˜å ç”¨ã€‚æ³¨æ„ï¼ŒColumn Pruningä¸€å®šè¦è‡ªä¸Šè€Œä¸‹ï¼Œå¦åˆ™ä¼šå¯¼è‡´pruningä¸å®Œå…¨ã€‚\n\nç¬¬äºŒä¸ªprojectionåº”prunedä¸ºï¼š\n```\nProjection: (output columns: #0.0, #0.1, #0.2, #0.3, #0.4, (#0.5 + #0.6), (#0.7 + #0.8), ((#0.9 + #0.10) + #0.11))\n\t\t\t\t\t\t\tï½œ\n\t\t\t\t\t\t\tï½œ\n\t\t\t\t\t\t\t\\/\nProjection: (output columns: #0.0, #0.1, ((#0.9 + #0.10) + #0.11))\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n```\n\nå¯¹äº Projection ç»“ç‚¹, åˆ†åˆ«å¤„ç†å­ç»“ç‚¹ä¸º Projection å’Œ Aggregation çš„æƒ…å†µ.\n- å¯¹äº Projection ç»“ç‚¹, ç”¨çˆ¶èŠ‚ç‚¹å¯¹å­ç»“ç‚¹ä¿®å‰ª, ç„¶åç”¨å­ç»“ç‚¹æ›¿æ¢çˆ¶èŠ‚ç‚¹.\n- å¯¹äº Aggregation ç»“ç‚¹, ç”¨ Projection ä¸­å‡ºç°çš„åˆ—æ£€æŸ¥ Aggregation ä¸­æ˜¯å¦å‡ºç°, è‹¥æ²¡æœ‰åˆ™åˆ é™¤. åŒæ—¶æ£€æŸ¥æ˜¯å¦å­˜åœ¨å†—ä½™, è‹¥å­˜åœ¨åˆ™åˆ é™¤.\n```cpp\nauto Optimizer::OptimizeColumnPruning(const AbstractPlanNodeRef &plan) -> AbstractPlanNodeRef {\n  std::shared_ptr<const AbstractPlanNode> optimized_plan = plan;\n\n  if (optimized_plan->GetType() == PlanType::Projection) {\n    auto projection_plan = dynamic_cast<const ProjectionPlanNode *>(optimized_plan.get());\n    auto child_plan = projection_plan->GetChildAt(0);\n\n    // Pruning when child is Projection.\n    if (child_plan->GetType() == PlanType::Projection) {\n      // Collect used cols.\n      std::vector<uint32_t> used_col_idxs;\n      used_col_idxs.reserve(optimized_plan->output_schema_->GetColumnCount());\n      for (const auto &expr : projection_plan->expressions_) {\n        CollectUsedColumnIdx(expr, used_col_idxs);\n      }\n      std::sort(used_col_idxs.begin(), used_col_idxs.end());\n      // Prune child.\n      auto child_projection_plan = dynamic_cast<const ProjectionPlanNode *>(child_plan.get());\n      std::vector<AbstractExpressionRef> pruned_exprs;\n      std::vector<Column> pruned_columns;\n      pruned_exprs.reserve(used_col_idxs.size());\n      pruned_columns.reserve(used_col_idxs.size());\n      for (uint32_t idx : used_col_idxs) {\n        pruned_exprs.push_back(child_projection_plan->expressions_[idx]);\n        pruned_columns.push_back(child_projection_plan->output_schema_->GetColumn(idx));\n      }\n      // Replace parent by its optimized child.\n      auto optimized_child_plan = std::make_shared<ProjectionPlanNode>(std::make_shared<Schema>(pruned_columns), \n          pruned_exprs, child_plan->children_[0]);\n      return OptimizeColumnPruning(optimized_child_plan);\n    }\n\n    // Pruning when child is Aggregation.\n    if (child_plan->GetType() == PlanType::Aggregation) {\n      // Collect used cols.\n      std::vector<uint32_t> used_col_idxs;\n      used_col_idxs.reserve(optimized_plan->output_schema_->GetColumnCount());\n      for (const auto &expr : projection_plan->expressions_) {\n        CollectUsedColumnIdx(expr, used_col_idxs);\n      }\n      std::sort(used_col_idxs.begin(), used_col_idxs.end());\n      // Prune child.\n      auto child_aggregation_plan = dynamic_cast<const AggregationPlanNode *>(child_plan.get());\n      size_t group_col_length = child_aggregation_plan->group_bys_.size();\n      std::vector<AbstractExpressionRef> pruned_aggregates;\n      std::vector<AggregationType> pruned_agg_types;\n      std::vector<Column> pruned_columns;\n      pruned_aggregates.reserve(used_col_idxs.size());\n      pruned_agg_types.reserve(used_col_idxs.size());\n      pruned_columns.reserve(used_col_idxs.size());\n      for (size_t i = 0; i < group_col_length; ++i) {\n        pruned_columns.push_back(child_aggregation_plan->output_schema_->GetColumn(i));\n      }\n      for (uint32_t idx : used_col_idxs) { // Maybe optimized to binary, upper_bound.\n        if (idx >= group_col_length) {\n          pruned_aggregates.push_back(child_aggregation_plan->aggregates_[idx - group_col_length]);\n          pruned_agg_types.push_back(child_aggregation_plan->agg_types_[idx - group_col_length]);\n          pruned_columns.push_back(child_aggregation_plan->output_schema_->GetColumn(idx));\n        }\n      }\n      // Make new optimized node child.\n      auto optimized_aggr = std::make_shared<AggregationPlanNode>(\n          std::make_shared<Schema>(pruned_columns), child_aggregation_plan->children_[0], \n          child_aggregation_plan->group_bys_, pruned_aggregates, pruned_agg_types);\n      // Modified parent node schema and expr.\n      std::vector<AbstractExpressionRef> pruned_exprs;\n      pruned_exprs.reserve(used_col_idxs.size());\n      for (const auto &expr : projection_plan->expressions_) {\n        pruned_exprs.push_back(PrunedProjectionExpression(expr, used_col_idxs));\n      }\n      optimized_plan = std::make_shared<ProjectionPlanNode>(projection_plan->output_schema_, pruned_exprs, optimized_aggr);\n      return optimized_plan->CloneWithChildren({OptimizeColumnPruning(optimized_plan->children_[0])});\n    }\n  }\n\n  if (optimized_plan->GetType() == PlanType::SeqScan || optimized_plan->GetType() == PlanType::MockScan ||\n      optimized_plan->GetType() == PlanType::IndexScan) {\n    return optimized_plan;\n  }\n\n  std::vector<AbstractPlanNodeRef> new_children{};\n  for (const auto &child : plan->children_) {\n    new_children.emplace_back(OptimizeColumnPruning(child));\n  }\n  return plan->CloneWithChildren(std::move(new_children));\n}\n```\nåˆ°äº†è¿™é‡Œï¼Œæˆ‘ä¹Ÿå‘ç°äº†æˆ‘OptimizeNLJAsHashJoin()çš„ä¸€ä¸ªbugï¼Œè¦åœ¨OptimizeNLJAsHashJoin()ä¸­éœ€è¦åŠ ä¸€è¡Œï¼š**å½“å°è¯•åœ¨Join Nodeä¸Šæ–¹ç”Ÿæˆæ–°çš„filter Nodeæ—¶å€™ï¼Œå¦‚joinç±»å‹ä¸æ˜¯Inner Join, è¦ä¿æŒNLJè€Œä¸èƒ½ä¼˜åŒ–æˆHash_Join**ã€‚\n\næˆ‘å®ç°OptimizeNLJAsHashJoin()çš„æ—¶å€™ä¼šå°è¯•å¤šç”Ÿæˆä¸€ä¸ªfilter Nodeï¼Œä½†æ˜¯å¦‚æœæ˜¯Left Join çš„è¯ï¼ŒJoinåçš„tupleä¸­æœ‰å¯èƒ½å‡ºç°null valueï¼Œè€Œæ–°çš„fileræœ‰å¯èƒ½ä¼šå¯¼è‡´è¿™äº›åŒ…å«null valueçš„tupleå…¨è¢«å»é™¤æ‰ã€‚æ‰€ä»¥åœ¨Left Joinçš„æ—¶å€™ï¼Œè¦ä¿æŒå»é™¤çš„åˆ¤æ–­è¯­å¥åœ¨Join Nodeå†…éƒ¨ï¼Œè€Œä¸èƒ½å‰¥ç¦»å¼€ã€‚æ‰€ä»¥å…¶å®gradescopeä¸Šç»™çš„åŸºç¡€æµ‹è¯•éå¸¸ä¸å…¨é¢ï¼Œå³ä½¿é€šè¿‡æ‰€ä»¥æµ‹è¯•ï¼Œä»£ç ä¹Ÿå¯èƒ½æœ‰å¾ˆå¤šå¾ˆå¤§çš„bugã€‚\n\ndebugå¹¶ä¼˜åŒ–åï¼š\n```\nProjection { exprs=[\"#0.0\", \"#0.1\", \"((#0.2+#0.3)+#0.4)\"] }\n\n  Agg { types=[\"max\", \"max\", \"max\", \"max\"]\n  ,aggregates=[\"#0.1\", \"#0.1\", \"#0.1\", \"#0.2\"]\n  ,group_by=[\"#0.0\"] }\n  \n    NestedLoopJoin { type=Left, predicate=(#0.0<#1.0) }\n    \n      MockScan { table=__mock_t7 }\n      \n      Values { rows=0 }\n```\næ­¤æ—¶å·²ç»å¯ä»¥è¾ƒå¿«åœ°é€šè¿‡q3äº†ï¼Œä½†ä½ ä¼šå‘ç°ï¼Œaggrä¸­å±…ç„¶è¿˜æœ‰é‡å¤çš„è®¡ç®—:\n```\n types=     [\"max\",  \"max\",  \"max\",  \"max\"],\n aggregates=[\"#0.1\", \"#0.1\", \"#0.1\", \"#0.2\"]\n```\nå¯¹é½ä¸€ä¸‹ï¼Œæ˜¾ç„¶å¯¹#0.1çš„maxå±…ç„¶è®¡ç®—äº†ä¸‰é...æ‰€ä»¥å¯ä»¥è¿›ä¸€æ­¥å¯¹aggregationå»é‡ã€‚\n\n```cpp\nvoid Optimizer::CollectUsedColumnIdx(const AbstractExpressionRef &expr, std::vector<uint32_t> &col_idxs) {\n  if (const auto *arith_expr = dynamic_cast<const ArithmeticExpression*>(expr.get())) {\n    CollectUsedColumnIdx(expr->children_[0], col_idxs);\n    CollectUsedColumnIdx(expr->children_[1], col_idxs);\n    return;\n  }\n  if (const auto *column_value_expr = dynamic_cast<const ColumnValueExpression *>(expr.get())) {\n    if (std::find(col_idxs.begin(), col_idxs.end(), column_value_expr->GetColIdx()) == col_idxs.end()) {\n      col_idxs.push_back(column_value_expr->GetColIdx());\n    }\n    return;\n  }\n  if (dynamic_cast<const ConstantValueExpression *>(expr.get())) {\n    return;\n  }\n  std::string message = \"Projection expressions should only contain arithmetic, column and constant: \";\n  UNREACHABLE(message);\n}\n\nauto Optimizer::PrunedProjectionExpression(const AbstractExpressionRef &expr, std::vector<int> idx_map) \n    -> AbstractExpressionRef {\n  // Notice: used_col_idxs is sorted.\n  if (const auto *arith_expr = dynamic_cast<const ArithmeticExpression *>(expr.get())) {\n    return expr->CloneWithChildren({PrunedProjectionExpression(expr->children_[0], idx_map),\n                                    PrunedProjectionExpression(expr->children_[1], idx_map)});\n  }\n  if (const auto *column_value_expr = dynamic_cast<const ColumnValueExpression *>(expr.get())) {\n    int new_col_idx = idx_map[column_value_expr->GetColIdx()];\n    return std::make_shared<ColumnValueExpression>(column_value_expr->GetTupleIdx(), new_col_idx, \n        column_value_expr->GetReturnType());\n  }\n  return expr;\n}\n\nauto Optimizer::OptimizeColumnPruning(const AbstractPlanNodeRef &plan) -> AbstractPlanNodeRef {\n  std::shared_ptr<const AbstractPlanNode> optimized_plan = plan;\n\n  if (optimized_plan->GetType() == PlanType::Projection) {\n    auto projection_plan = dynamic_cast<const ProjectionPlanNode *>(optimized_plan.get());\n    auto child_plan = projection_plan->GetChildAt(0);\n\n    // Pruning when child is Projection.\n    if (child_plan->GetType() == PlanType::Projection) {\n      // Collect used cols.\n      std::vector<uint32_t> used_col_idxs;\n      used_col_idxs.reserve(optimized_plan->output_schema_->GetColumnCount());\n      for (const auto &expr : projection_plan->expressions_) {\n        CollectUsedColumnIdx(expr, used_col_idxs);\n      }\n      std::sort(used_col_idxs.begin(), used_col_idxs.end());\n      // Prune child.\n      auto child_projection_plan = dynamic_cast<const ProjectionPlanNode *>(child_plan.get());\n      std::vector<AbstractExpressionRef> pruned_exprs;\n      std::vector<Column> pruned_columns;\n      pruned_exprs.reserve(used_col_idxs.size());\n      pruned_columns.reserve(used_col_idxs.size());\n      for (uint32_t idx : used_col_idxs) {\n        pruned_exprs.push_back(child_projection_plan->expressions_[idx]);\n        pruned_columns.push_back(child_projection_plan->output_schema_->GetColumn(idx));\n      }\n      // Replace parent by its optimized child.\n      auto optimized_child_plan = std::make_shared<ProjectionPlanNode>(std::make_shared<Schema>(pruned_columns), \n          pruned_exprs, child_plan->children_[0]);\n      return OptimizeColumnPruning(optimized_child_plan);\n    }\n\n    // Pruning when child is Aggregation.\n    if (child_plan->GetType() == PlanType::Aggregation) {\n      auto child_aggregation_plan = dynamic_cast<const AggregationPlanNode *>(child_plan.get());\n\n      // Collect used cols.\n      std::vector<uint32_t> used_col_idxs;\n      used_col_idxs.reserve(optimized_plan->output_schema_->GetColumnCount());\n      size_t group_cols = child_aggregation_plan->GetGroupBys().size();\n      for (size_t i = 0; i < group_cols; ++i) {\n        // Must use group by columns.\n        used_col_idxs.push_back(i);\n      }\n      for (const auto &expr : projection_plan->expressions_) {\n        CollectUsedColumnIdx(expr, used_col_idxs);\n      }\n      std::sort(used_col_idxs.begin(), used_col_idxs.end());\n\n      // Prune child.\n      size_t group_col_length = child_aggregation_plan->group_bys_.size();\n      std::vector<AbstractExpressionRef> pruned_aggregates;\n      std::vector<AggregationType> pruned_agg_types;\n      std::vector<Column> pruned_columns;\n      // For aggr deduplication, [expression.toString + AggregationType]\n      std::unordered_map<std::string, uint32_t> exist_expr;\n      std::unordered_map<uint32_t, uint32_t> re_direct;\n\n      pruned_aggregates.reserve(used_col_idxs.size());\n      pruned_agg_types.reserve(used_col_idxs.size());\n      pruned_columns.reserve(used_col_idxs.size());\n\n      for (size_t i = 0; i < group_col_length; ++i) {\n        pruned_columns.push_back(child_aggregation_plan->output_schema_->GetColumn(i));\n      }\n      for (uint32_t idx : used_col_idxs) { // Maybe optimized to binary, upper_bound.\n        if (idx >= group_col_length) {  // idx >= group_col_length means it's aggr.\n          auto aggr_expr = child_aggregation_plan->aggregates_[idx - group_col_length];\n          auto aggr_type = child_aggregation_plan->agg_types_[idx - group_col_length];\n          std::string aggr_pair = aggr_expr->ToString() + std::to_string(static_cast<int>(aggr_type));\n          if (exist_expr.count(aggr_pair) == 0) {\n            // Not exist yet, add to pruned lists.\n            pruned_aggregates.push_back(aggr_expr);\n            pruned_agg_types.push_back(aggr_type);\n            pruned_columns.push_back(child_aggregation_plan->output_schema_->GetColumn(idx));\n            exist_expr[aggr_pair] = pruned_columns.size() - 1;\n          } else {\n            // Has existed, add to re_direct map.\n            re_direct[idx] = exist_expr.find(aggr_pair)->second;\n          }\n        }\n      }\n\n      // Make new optimized node child.\n      auto optimized_aggr = std::make_shared<AggregationPlanNode>(\n          std::make_shared<Schema>(pruned_columns), child_aggregation_plan->children_[0], \n          child_aggregation_plan->group_bys_, pruned_aggregates, pruned_agg_types);\n\n      // Modified parent node schema and expr.\n      std::vector<AbstractExpressionRef> pruned_exprs;\n      pruned_exprs.reserve(used_col_idxs.size());\n      std::vector<int> idx_map = RearrangeColIdxs(re_direct, used_col_idxs);\n\n      for (const auto &expr : projection_plan->expressions_) {\n        pruned_exprs.push_back(PrunedProjectionExpression(expr, idx_map));\n      }\n      optimized_plan = std::make_shared<ProjectionPlanNode>(projection_plan->output_schema_, pruned_exprs, optimized_aggr);\n      return optimized_plan->CloneWithChildren({OptimizeColumnPruning(optimized_plan->children_[0])});\n    }\n  }\n\n  if (optimized_plan->GetType() == PlanType::SeqScan || optimized_plan->GetType() == PlanType::MockScan ||\n      optimized_plan->GetType() == PlanType::IndexScan) {\n    return optimized_plan;\n  }\n\n  std::vector<AbstractPlanNodeRef> new_children{};\n  for (const auto &child : plan->children_) {\n    new_children.emplace_back(OptimizeColumnPruning(child));\n  }\n  return plan->CloneWithChildren(std::move(new_children));\n}\n\nauto Optimizer::RearrangeColIdxs(std::unordered_map<uint32_t, uint32_t> &re_direct, std::vector<uint32_t> &used_col_idxs) \n    -> std::vector<int> {\n  // Initialize the result map and the del array\n  int max_col_idx = static_cast<int>(used_col_idxs.back());\n  std::vector<int> col_idx_map(max_col_idx + 1, -1);\n  std::vector<int> del(max_col_idx + 2, 0);\n\n  // Cache the result of std::lower_bound for each i\n  std::vector<uint32_t> idx_map(max_col_idx + 1, used_col_idxs.size());\n  for (int i = 0; i <= max_col_idx; ++i) {\n    idx_map[i] = std::find(used_col_idxs.begin(), used_col_idxs.end(), i) - used_col_idxs.begin();\n  }\n\n  // First pass: Fill col_idx_map and update del\n  for (int i = 0; i <= max_col_idx; ++i) { // 11\n    uint32_t idx = idx_map[i];\n    if (idx < used_col_idxs.size()) {\n      if (re_direct.count(i)) {\n        col_idx_map[i] = re_direct[i];\n        del[idx + 1] -= 1;\n      } else {\n        // When it's not in re_direct.\n        col_idx_map[i] = idx;\n      }\n    }\n  }\n\n  // Compute cumulative del values\n  for (size_t i = 1; i < del.size(); ++i) {\n    del[i] += del[i - 1];\n  }\n\n  // Final adjustment for col_idx_map\n  for (int i = 0; i <= max_col_idx; ++i) {\n    uint32_t idx = idx_map[i];\n    if (col_idx_map[i] != -1 && !re_direct.count(idx)) {\n      col_idx_map[i] += del[col_idx_map[i]];\n    }\n  }\n\n  /*\n    printf(\"re_direct:\");\n    printUnorderedMap(re_direct);\n    printf(\"idx_map:\");\n    printVector(idx_map);\n    printf(\"del:\");\n    printVector(del);\n    printf(\"used_col_idxs:\");\n    printVector(used_col_idxs);\n    printf(\"col_idx_map:\");\n    printVector(col_idx_map);\n  */\n\n  return col_idx_map;\n}\n```\n\nä¼˜åŒ–åï¼š\n\n```\nProjection { exprs=[\"#0.0\", \"#0.1\", \"((#0.1+#0.1)+#0.2)\"] } \n| (__subquery#0.t7.v:INTEGER, __subquery#0.d1:INTEGER, __subquery#0.d2:INTEGER)\n\n  Agg { types=[\"max\", \"max\"], aggregates=[\"#0.1\", \"#0.2\"], group_by=[\"#0.0\"] } \n  | (t7.v:INTEGER, agg#0:INTEGER, agg#10:INTEGER)\n  \n    NestedLoopJoin { type=Left, predicate=(#0.0<#1.0) } \n    | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER, __subquery#1.t8.v4:INTEGER)\n    \n      SeqScan { table=t7 } | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER)\n      \n      Values { rows=0 } | (__subquery#1.t8.v4:INTEGER)\n```\nå¯è§aggråªè®¡ç®—äº†ä¸¤ä¸ªmaxã€‚\n\nç°åœ¨q3ç”¨æ—¶å¯ä»¥è¾¾åˆ°700å¤šï¼Œå¹¶ä¸”å…¶ä»–æµ‹è¯•ä¹Ÿéƒ½å¯ä»¥é€šè¿‡ã€‚\n\n# åè®°\nç”±äºç»™çš„åŸºç¡€æµ‹è¯•å¤ªä¸å…¨é¢äº†ï¼Œå¯¼è‡´æˆ‘è‡ªå·±åˆå†™äº†ä¸€ç‚¹ï¼Œä½†ä»ç„¶ä¸å…¨é¢ã€‚æ‰€ä»¥**å®é™…ä¸Šæˆ‘çš„ä»£ç è‚¯å®šè¿˜æœ‰bug**ï¼Œåªæ˜¯è¿˜æ²¡æ‰¾åˆ°ä¸”ä¸å½±å“çº¿ä¸Šæµ‹è¯•ã€‚æƒ³ç”¨çº¿ä¸Šæµ‹è¯•å°±å¿…é¡»è¦éµå¾ªä¸€äº›ä»£ç æ ¼å¼ï¼Œæ¯”å¦‚ä¸èƒ½æ–°å¢æ–‡ä»¶ï¼ŒæŸäº›å‡½æ•°åªèƒ½å†™åœ¨ç‰¹å®šæ–‡ä»¶ï¼Œå¤§éƒ¨åˆ†åˆå§‹ä»£ç ä¸èƒ½è‡ªå·±ä¿®æ”¹...è¿™äº›ä¸œè¥¿å¾ˆå¤§åœ°é™åˆ¶äº†å‘æŒ¥ï¼ŒçœŸè¯šå¸Œæœ›ä»¥åèƒ½æ”¹è¿›ä¸€ä¸‹ï¼Œç»™æˆ‘ä»¬æ›´å¤šè‡ªç”±åº¦ï¼Œè‡³å°‘èƒ½æ–°å¢æ–‡ä»¶å§ã€‚ã€‚ã€‚\n\nç›®å‰ä¸‰ä¸ªleaderboard testæ€»åˆ†æ’åè¿›äº†å‰åï¼Œè€Œäº‹å®ä¸Š23fallä¹Ÿæ²¡æœ‰å¤šå°‘äººçœŸæ­£å®Œæˆäº†project 3 çš„å…¨éƒ¨leaderboardéƒ¨åˆ†ã€‚æ‰€è°“çš„cmu15445çƒ‚å¤§è¡—ï¼Œå…¶å®ç¡®å®æ˜¯ä¸ªè°è¨€ã€‚äº‹å®ä¸Š23fallçš„project 3 leaderboardåšå®Œçš„åªæœ‰ä¸åˆ°20ä¸ªäººï¼Œæ›´åˆ«è¯´project 4äº†ã€‚\n\n**æˆ‘è®¤ä¸ºproject 3æ˜¯æœ€é‡è¦çš„ä¸€ä¸ªproject**ã€‚åšè¿‡å‰ä¸¤ä¸ªprojectçš„éƒ½çŸ¥é“ï¼Œproject 1ã€2 å’Œæ•°æ®åº“ç»“æ„çœŸæ²¡å•¥å¤ªå¤§å…³ç³»ã€‚æ‰€ä»¥å½“æˆ‘åšå®Œ1ã€2çš„æ—¶å€™ï¼Œå¯¹æ•°æ®åº“å…·ä½“ç»“æ„æ˜¯å‡ ä¹æ²¡æœ‰è¿›ä¸€æ­¥äº†è§£ã€‚è€Œproject 3 æ‰æ˜¯çœŸæ­£æ·±å…¥Bustubæ‰§è¡Œè¿‡ç¨‹ï¼Œæˆ‘åšå®Œ3åæ‰å¯¹æ•°æ®åº“å„ä¸ªç»„ä»¶æœ‰äº†ä¸€ä¸ªçœŸæ­£ç›´è§‚çš„è®¤è¯†ã€‚éå¸¸æ¨èè‡ªå·±è®¤çœŸå®Œæˆè¿™ä¸ªprojectã€‚\n\nè´´å‡ºæ¥çš„ä»£ç è·Ÿä¸€å¨ç­”è¾©ä¸€æ ·ï¼Œåç»­æˆ‘å¯¹ä»£ç è¿›è¡Œäº†ä¸€äº›é‡æ„ï¼Œä½†ç°åœ¨çœŸæ˜¯ç´¯æ­»äº†ï¼Œå†™ä¸åŠ¨äº†ã€‚ä½†è¯è¯´èµ·æ¥ï¼Œè¿™ä¸€å¨ä¹Ÿè®©è¯»è€…é˜…è¯»èµ·æ¥æ›´å›°éš¾ï¼Œä¹Ÿç®—é—´æ¥ä¿æŠ¤äº†è¯¾ç¨‹æ— æ³•è¢«æŠ„è¢­ã€‚ã€‚ã€‚\n\n","tags":["æ•°æ®åº“","Bustub"],"categories":["æ•°æ®åº“"]},{"title":"Hello World","url":"/2024/12/07/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]