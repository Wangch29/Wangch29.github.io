[{"title":"Project 3 leaderboard 优化","url":"/2024/12/08/Bustub/project3-leaderboard/","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这是一个关于我自己的cmu15-445 project 3 leaderboard部分的攻略，不会涉及其前面基础实现部分。最终效果三个部分平均用时2000以内，进了排行榜前十。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/059ce9aa4865460797af7c48176abc08.png#pic_center\"><br>引自<a href=\"https://www.cnblogs.com/joey-wang/p/17351258.html\">joey-wang</a></p>\n<h1 id=\"Query-1-TopNPerGroupPlan\"><a href=\"#Query-1-TopNPerGroupPlan\" class=\"headerlink\" title=\"Query 1: TopNPerGroupPlan\"></a>Query 1: TopNPerGroupPlan</h1><p>根据例子：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t1(x <span class=\"type\">INT</span>, y <span class=\"type\">INT</span>, z <span class=\"type\">INT</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> x, y <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> x, y, <span class=\"built_in\">rank</span>() <span class=\"keyword\">OVER</span> (<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> x <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> y) <span class=\"keyword\">as</span> rank</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> t1</span><br><span class=\"line\">) <span class=\"keyword\">WHERE</span> rank <span class=\"operator\">&lt;=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>首先可以通过Bustub shell 里的 explain 得其目前的 plan tree，来分析一下执行过程:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;] &#125;</span><br><span class=\"line\">  Filter &#123; predicate=(#0.2&lt;=3) &#125;</span><br><span class=\"line\">    WindowFunc &#123;</span><br><span class=\"line\">      columns=#0.0, #0.1, placeholder, ,</span><br><span class=\"line\">      window_functions=&#123;</span><br><span class=\"line\">        2=&gt;&#123; function_arg=1, type=rank, partition_by=[&quot;#0.0&quot;], order_by=[(&quot;Default&quot;, &quot;#0.1&quot;)] &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      SeqScan &#123; table=t1 &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可看出其有四个plan node，执行顺序如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Seqscan -&gt; WindowFunc -&gt; Filter -&gt; Projection</span><br></pre></td></tr></table></figure>\n\n<p>当满足Projection &lt;-Filter &lt;- WindowFunc顺序，且projection将windowFunc产生的rank列清除时，它们三个node可以合并成一个TopNPerGroupPlan，扫描后直接返回每个group排名前N的tuple，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Seqscan -&gt; TopNPerGroupPlan</span><br></pre></td></tr></table></figure>\n<p>即可在optimizer.h新增一个优化pattern：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">OptimizeProjectionFilterWindowAsTopGroupN</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef</span>;</span><br></pre></td></tr></table></figure>\n<p>你会发现原本bustub自带的优化method实现都是在一个新的.cpp文件中，为了统一格式你自然会想到新创建一个OptimizeProjectionFilterWindowAsTopGroupN.cpp来实现该函数，再加入cmakelists里。但事与愿违，由于gradescope的限制，如果你想线上测试，就不能自己新建文件，而要在项目指定optimizer_custom_rules.cpp里实现。这点会让optimizer_custom_rules.cpp往后变的很臃肿，希望课程以后能改进这一点吧。。。</p>\n<p>主要思路是利用一个可以保留多个tuple 的特殊priority queue来为每个组保留top N个tuple。注意如果有相等的tuple，需要同时保留，例子可见p3.leaderboard_test_q1_window。还要用一个hashmap 来分组。过程就是：先拿到一个tuple，然后获得其group值，利用group值做key在一个<strong>hashmap</strong>中找到其所在group对应的priority queue，然后插入。这时候只需要<strong>自定义一下这个priority queue，让其自动保存前n个tuple就可以了。</strong></p>\n<p>对于OptimizeProjectionFilterWindowAsTopGroupN，则是依次查看三层nodeplan，如果满足“<em><strong>Projection &lt;-Filter &lt;- WindowFunc顺序，且projection将windowFunc产生的rank列清除时</strong></em>”，即可优化成TopNPerGroup node。可以利用shell中的explain (o)语句来查看优化是否成功。</p>\n<p>具体实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizeProjectionFilterWindowAsTopGroupN</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; optimized_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    optimized_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeProjectionFilterWindowAsTopGroupN</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> optimized_plan = plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(optimized_children));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// First node is Projection.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode &amp;&gt;(*optimized_plan);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> &amp;first_child = projection_plan.<span class=\"built_in\">GetChildren</span>().<span class=\"built_in\">at</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Second node is filter.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first_child-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Filter) &#123;</span><br><span class=\"line\">      <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;filter_child = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> FilterPlanNode &amp;&gt;(*first_child);</span><br><span class=\"line\">      <span class=\"comment\">// auto filter_logic_expr = dynamic_cast&lt;const LogicExpression&amp;&gt;(filter_child.predicate_);</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> &amp;second_child = filter_child.<span class=\"built_in\">GetChildren</span>().<span class=\"built_in\">at</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"comment\">// Third node is window.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (second_child-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Window) &#123;</span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;window_child = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> WindowFunctionPlanNode &amp;&gt;(*second_child);</span><br><span class=\"line\">        <span class=\"comment\">// Try to find Rank&#x27;s col index.</span></span><br><span class=\"line\">        <span class=\"type\">int</span> rank_idx = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        std::string rank_name;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> col = <span class=\"number\">0</span>; col &lt; window_child.columns_.<span class=\"built_in\">size</span>(); ++col) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (window_child.window_functions_.<span class=\"built_in\">find</span>(rank_idx) != window_child.window_functions_.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Is a window function</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (window_child.window_functions_.<span class=\"built_in\">at</span>(rank_idx).type_ == WindowFunctionType::Rank) &#123;</span><br><span class=\"line\">              rank_idx = col;</span><br><span class=\"line\">              rank_name = window_child.<span class=\"built_in\">OutputSchema</span>().<span class=\"built_in\">GetColumn</span>(rank_idx).<span class=\"built_in\">GetName</span>();</span><br><span class=\"line\">              <span class=\"keyword\">goto</span> OptimizeProjectionFilterWindowAsTopGroupN_END;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// If we find Rank, we can continue to check if it stays after projection.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rank_idx != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;projection_schema = projection_plan.<span class=\"built_in\">OutputSchema</span>();</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;column : projection_schema.<span class=\"built_in\">GetColumns</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (column.<span class=\"built_in\">GetName</span>() == rank_name) &#123;  <span class=\"comment\">// Find the rank line</span></span><br><span class=\"line\">              <span class=\"keyword\">goto</span> OptimizeProjectionFilterWindowAsTopGroupN_END;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Projection removed RANK, we can optimize it to TopGroupN node.</span></span><br><span class=\"line\">        <span class=\"comment\">// Find group_bys</span></span><br><span class=\"line\">        <span class=\"type\">const</span> std::vector&lt;AbstractExpressionRef&gt; &amp;group_by =</span><br><span class=\"line\">            window_child.window_functions_.<span class=\"built_in\">begin</span>()-&gt;second.partition_by_;</span><br><span class=\"line\">        <span class=\"comment\">// Find order by</span></span><br><span class=\"line\">        <span class=\"type\">const</span> std::vector&lt;std::pair&lt;OrderByType, AbstractExpressionRef&gt;&gt; &amp;order_by =</span><br><span class=\"line\">            window_child.window_functions_.<span class=\"built_in\">begin</span>()-&gt;second.order_by_;</span><br><span class=\"line\">        <span class=\"comment\">// Find top n;</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> value_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ConstantValueExpression &amp;&gt;(*filter_child.predicate_-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"comment\">// auto value_expr = dynamic_cast&lt;const ConstantValueExpression &amp;&gt;(*maybe_value_expr);</span></span><br><span class=\"line\">        <span class=\"type\">int</span> n = value_expr.val_.<span class=\"built_in\">CastAs</span>(TypeId::INTEGER).<span class=\"built_in\">GetAs</span>&lt;<span class=\"type\">int</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;TopNPerGroupPlanNode&gt;(projection_plan.output_schema_, window_child.children_.<span class=\"built_in\">at</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">                                                      group_by, order_by, n);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">OptimizeProjectionFilterWindowAsTopGroupN_END:</span><br><span class=\"line\">  <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在topn_per_group_executor.cpp：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TopNPerGroupExecutor::Init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  child_executor_-&gt;<span class=\"built_in\">Init</span>();</span><br><span class=\"line\">  partition_top_n_.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"type\">size_t</span> top_n = plan_-&gt;n_;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> group_by = plan_-&gt;<span class=\"built_in\">GetGroupBy</span>();</span><br><span class=\"line\">  <span class=\"function\">CompareTuple <span class=\"title\">comparator</span><span class=\"params\">(&amp;plan_-&gt;GetOrderBy(), &amp;child_executor_-&gt;GetOutputSchema())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Use a priority queue to store the top N tuples for each group.</span></span><br><span class=\"line\">  Tuple tuple;</span><br><span class=\"line\">  RID rid;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (child_executor_-&gt;<span class=\"built_in\">Next</span>(&amp;tuple, &amp;rid)) &#123;   <span class=\"comment\">// nlogn</span></span><br><span class=\"line\">    AggregateKey group_by_key = <span class=\"built_in\">ConstructGroupByTuple</span>(tuple, group_by);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = partition_top_n_.<span class=\"built_in\">find</span>(group_by_key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (partition_top_n_.<span class=\"built_in\">find</span>(group_by_key) == partition_top_n_.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      it = partition_top_n_.<span class=\"built_in\">emplace</span>(group_by_key, <span class=\"built_in\">TopNTuplePriorityQueue</span>(top_n, comparator)).first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    it-&gt;second.<span class=\"built_in\">Push</span>(tuple);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  iter_ = partition_top_n_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">TopNPerGroupExecutor::Next</span><span class=\"params\">(Tuple *tuple, RID *rid)</span> -&gt; <span class=\"type\">bool</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (iter_ != partition_top_n_.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iter_-&gt;second.<span class=\"built_in\">Empty</span>()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Move to the next pq, and erase current pq.</span></span><br><span class=\"line\">      iter_ = partition_top_n_.<span class=\"built_in\">erase</span>(iter_);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Next</span>(tuple, rid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *tuple = iter_-&gt;second.<span class=\"built_in\">Pop</span>();</span><br><span class=\"line\">    *rid = tuple-&gt;<span class=\"built_in\">GetRid</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义版priority queue：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TopNTuplePriorityQueue</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">TopNTuplePriorityQueue</span><span class=\"params\">(std::<span class=\"type\">size_t</span> n, CompareTuple comparator)</span></span></span><br><span class=\"line\"><span class=\"function\">      : n_(n), pq_(comparator), freq_map_(comparator) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Push</span><span class=\"params\">(<span class=\"type\">const</span> Tuple &amp;tuple)</span> </span>&#123;</span><br><span class=\"line\">    pq_.<span class=\"built_in\">push</span>(tuple);</span><br><span class=\"line\">    freq_map_[tuple] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">MaintainSize</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> -&gt; Tuple </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pq_.<span class=\"built_in\">empty</span>()) [[unlikely]] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> std::<span class=\"built_in\">runtime_error</span>(<span class=\"string\">&quot;TopNTuplePriorityQueue is empty&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Tuple top_tuple = pq_.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    pq_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_tuple;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Empty</span><span class=\"params\">()</span> -&gt; <span class=\"type\">bool</span> </span>&#123; <span class=\"keyword\">return</span> pq_.<span class=\"built_in\">empty</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  std::<span class=\"type\">size_t</span> n_;</span><br><span class=\"line\">  std::priority_queue&lt;Tuple, std::vector&lt;Tuple&gt;, CompareTuple&gt; pq_;</span><br><span class=\"line\">  std::map&lt;Tuple, <span class=\"type\">size_t</span>, CompareTuple&gt; freq_map_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MaintainSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pq_.<span class=\"built_in\">size</span>() &gt; n_) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If removing top elements will lead to underflow, break;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (pq_.<span class=\"built_in\">size</span>() - freq_map_[pq_.<span class=\"built_in\">top</span>()] &lt; n_) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Remove top tuples.</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (freq_map_[pq_.<span class=\"built_in\">top</span>()] &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        freq_map_[pq_.<span class=\"built_in\">top</span>()] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        pq_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      freq_map_.<span class=\"built_in\">erase</span>(pq_.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">      pq_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在top_n_per_group.h中的TupleComparator和其他一些东西就留给读者思考，不写出了，具体思路我已经在上面讲过了。而这个玩意的输出不需要按照一定顺序比如升序，只需要获得的tuple对就行。</p>\n<p>至此即可通过leaderboard test q1，我的用时目前是7000多，排十多名，在做了优化的人中算是慢的了，看来还有优化空间。</p>\n<p>做个profiling看看👀：<br><img src=\"https://i-blog.csdnimg.cn/direct/bc28397020ab4437bbce3ac400b42368.png#pic_center\" alt=\"在这里插入图片描述\"><br>我发现TopNTuplePriorityQueue中的**MaintainSize()<strong>函数比我想象的耗时间。MaintainSize占据了Push过半的时间，而</strong>freq_map_[]**又占据了MaintainSize过半的时间，所以用基于红黑树的map还是不行，可以把 std::map&lt;Tuple, size_t, CompareTuple&gt; freq_map_ 优化成 unordered_map。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MaintainSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (pq_.<span class=\"built_in\">size</span>() &gt; n_) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If removing top elements will lead to underflow, break;</span></span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> top_tuple_freq = freq_map_[pq_.<span class=\"built_in\">top</span>()];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pq_.<span class=\"built_in\">size</span>() - top_tuple_freq &lt; n_) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Remove top tuples.</span></span><br><span class=\"line\">        freq_map_.<span class=\"built_in\">erase</span>(pq_.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; top_tuple_freq; ++i) &#123;</span><br><span class=\"line\">          pq_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">std::unordered_map&lt;Tuple, <span class=\"type\">size_t</span>, TupleHash, TupleEqual&gt; freq_map_;</span><br></pre></td></tr></table></figure>\n\n<p>然后再测试，发现居然q1用时直接从7000多减少到了4000多，快了40%多，效果十分显著啊。可见profiling对优化的指导还是很有效的。</p>\n<p>优化后再做个profiling：<br><img src=\"https://i-blog.csdnimg.cn/direct/56f81ad3ada240c29acd9eecd359ed73.png#pic_center\" alt=\"在这里插入图片描述\"><br>可见Push()用时大幅缩短。但leaderboard上还有神人能优化到1000多，真不知怎么做到的。</p>\n<h1 id=\"Query-2-Too-Many-Joins\"><a href=\"#Query-2-Too-Many-Joins\" class=\"headerlink\" title=\"Query 2: Too Many Joins!\"></a>Query 2: Too Many Joins!</h1><h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>一名来自<a href=\"https://zh.wikipedia.org/wiki/%E8%8C%83%E5%B0%8F%E5%8B%A4\">严辉村</a>的村民写了如下的sql：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t4(x <span class=\"type\">int</span>, y <span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t5(x <span class=\"type\">int</span>, y <span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t6(x <span class=\"type\">int</span>, y <span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t4, t5, t6</span><br><span class=\"line\">  <span class=\"keyword\">WHERE</span> (t4.x <span class=\"operator\">=</span> t5.x) <span class=\"keyword\">AND</span> (t5.y <span class=\"operator\">=</span> t6.y) <span class=\"keyword\">AND</span> (t4.y <span class=\"operator\">&gt;=</span> <span class=\"number\">1000000</span>)</span><br><span class=\"line\">    <span class=\"keyword\">AND</span> (t4.y <span class=\"operator\">&lt;</span> <span class=\"number\">1500000</span>) <span class=\"keyword\">AND</span> (t6.x <span class=\"operator\">&gt;=</span> <span class=\"number\">100000</span>) <span class=\"keyword\">AND</span> (t6.x <span class=\"operator\">&lt;</span> <span class=\"number\">150000</span>);</span><br></pre></td></tr></table></figure>\n<p>可见他其实想吧<strong>t4、t5 join on x, t5、t6 join on y</strong>, 但是并没有人为地分步合并，而是一股脑地把条件全放在了<strong>where</strong>后面。如果没有优化，就导致该query执行的时候会把t4、t5、t6做两个笛卡尔积（<strong>Cartesian product</strong>，即无条件的join）生产一个巨大的table，然后遍历这个巨大的table进行过滤。</p>\n<p>当然，你在前面已经实现了包括<strong>hash join</strong>在内的部分优化器，所以实际上根据我个人前面的实现，会先对t4、t5进行一个基于hash join的笛卡尔积，然后再和t6进行一个有条件的hash join，最后进行一个过滤（filter node）。</p>\n<p>具体经过用explain (o)可看其plan tree:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">Filter &#123; predicate=(((((#0.0=#0.2)and(#0.1&gt;=1000000))and(#0.1&lt;1500000))and</span><br><span class=\"line\">(#0.4&gt;=100000))and(#0.4&lt;150000)) &#125; | </span><br><span class=\"line\">(t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">  HashJoin &#123; type=Inner, left_key=[&quot;#0.3&quot;], right_key=[&quot;#1.1&quot;] &#125; | </span><br><span class=\"line\">  (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\">  </span><br><span class=\"line\">    HashJoin &#123; type=Inner, left_key=[], right_key=[] &#125; | </span><br><span class=\"line\">    (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">      SeqScan &#123; table=t4 &#125; | (t4.x:INTEGER, t4.y:INTEGER)</span><br><span class=\"line\">      SeqScan &#123; table=t5 &#125; | (t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    SeqScan &#123; table=t6 &#125; | (t6.x:INTEGER, t6.y:INTEGER)</span><br></pre></td></tr></table></figure>\n<p>这个根据每个人之前对<strong>Optimizer::OptimizeNLJAsHashJoin(</strong>)实现的不同，这里的情况也会有不同。</p>\n<h2 id=\"关于Hash-Join\"><a href=\"#关于Hash-Join\" class=\"headerlink\" title=\"关于Hash Join\"></a>关于Hash Join</h2><p>而OptimizeNLJAsHashJoin其实还挺繁琐的，根据我对gradescope上leaderboard的观察，有很多人对这个函数的实现其实的错误的，<strong>只是因为gradescope上的基础测试并不全面，他们才通过了除leaderboard外其余的基础测试</strong>。而到了leaderboard测试，就会出现bug了。</p>\n<p>所以我讲一下我的hashjoin的实现思路：大概是用一个递归遍历NLJ_plan.predicate的tree，当发现<strong>ColumnValueExpression</strong>且判断式为equal且其左右孩子expression均为ColumnValueExpression且GetTupleIdx()分列左右的时候，将其加入hash join并从原expression tree中删除。而遍历后剩下的expression tree则用于创建一个filter放在hash join 上方。而且在生成filter的时候要记得修改ColumnValueExpression的col_idx。</p>\n<p>举个例子：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t4, t5</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> (t4.x <span class=\"operator\">=</span> t5.x) <span class=\"keyword\">AND</span> (t4.x <span class=\"operator\">=</span> t4.y) <span class=\"keyword\">AND</span> (t4.z <span class=\"operator\">&gt;=</span> t5.z) <span class=\"keyword\">AND</span> (t5.x <span class=\"operator\">=</span> <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n<p>这个query会被优化成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Filter: (t4.x = t4.y) AND (t4.z &gt;= t5.z) AND (t5.z = 100)</span><br><span class=\"line\">         │</span><br><span class=\"line\">         └── HashJoin: t4.x = t5.x</span><br><span class=\"line\">             ├── Sequential Scan: t4</span><br><span class=\"line\">             └── Sequential Scan: t5</span><br></pre></td></tr></table></figure>\n<p>四个条件只有$t4.x &#x3D; t5.x$能被放入hash join, 因为$t4.x &#x3D; t4.y$只作用在left child， $t4.z &gt;&#x3D; t5.z$不是等式而是不等式，$t5.x &#x3D; 100$只作用于right child且有一个常数项。所以这三个判断都上移到filter。</p>\n<p>而还要考虑更复杂的NLJ的条件中logic连接词为<strong>OR</strong>的情况，如:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t4, t5</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> (t4.x <span class=\"operator\">=</span> t5.x) <span class=\"keyword\">OR</span> (t4.y <span class=\"operator\">=</span> t5.y);</span><br></pre></td></tr></table></figure>\n<p>我目前的做法是如果存在OR就直接保持NLJ，但其实可以这样优化成：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> t4, t5</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> t4.x <span class=\"operator\">=</span> t5.x</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> t4, t5</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> t4.y <span class=\"operator\">=</span> t5.y;</span><br></pre></td></tr></table></figure>\n<p>或者用tree表达：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Union All</span><br><span class=\"line\">├── HashJoin: t4.x = t5.x</span><br><span class=\"line\">│   ├── Sequential Scan: t4</span><br><span class=\"line\">│   └── Sequential Scan: t5</span><br><span class=\"line\">└── HashJoin: t4.y = t5.y</span><br><span class=\"line\">    ├── Sequential Scan: t4</span><br><span class=\"line\">    └── Sequential Scan: t5</span><br></pre></td></tr></table></figure>\n<p>即将OR连接的部分拆分成两个hash join，然后再Union起来。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>回到正题，这个query就是故意设计一个predicate集中分布在node tree上方，主要考察的是优化器对predicate pushdown的能力。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Filter &#123; predicate=(((((#0.0=#0.2)and(#0.1&gt;=1000000))and(#0.1&lt;1500000))and</span><br><span class=\"line\">(#0.4&gt;=100000))and(#0.4&lt;150000)) &#125; | </span><br><span class=\"line\">(t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">  HashJoin &#123; type=Inner, left_key=[&quot;#0.3&quot;], right_key=[&quot;#1.1&quot;] &#125; | </span><br><span class=\"line\">  (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\">  </span><br><span class=\"line\">    HashJoin &#123; type=Inner, left_key=[], right_key=[] &#125; | </span><br><span class=\"line\">    (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">      SeqScan &#123; table=t4 &#125; | (t4.x:INTEGER, t4.y:INTEGER)</span><br><span class=\"line\">      SeqScan &#123; table=t5 &#125; | (t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    SeqScan &#123; table=t6 &#125; | (t6.x:INTEGER, t6.y:INTEGER)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Query Plan Node Tree</span><br><span class=\"line\"></span><br><span class=\"line\">Filter: (t4.y = t5.y) AND (t4.x &gt;= 1000000)) AND (t4.x &lt; 1500000)) </span><br><span class=\"line\">|\t\t\tAND (t6.x &gt;= 100000)) AND (t6.x &lt; 150000))</span><br><span class=\"line\">│</span><br><span class=\"line\">└── HashJoin: t5.y = t6.y</span><br><span class=\"line\">    ├── HashJoin: t4.x = t5.x</span><br><span class=\"line\">    │   ├── Sequential Scan: t4</span><br><span class=\"line\">    │   └── Sequential Scan: t5</span><br><span class=\"line\">    └── Sequential Scan: t6</span><br></pre></td></tr></table></figure>\n<p>画出plan node tree 可以看出，根据我之前的实现，predicate都飘在最上方，现在要做的是把predicate下推，其在后续优化函数的作用下可以与<strong>NLJ、seq_scan</strong>等node合并。</p>\n<p>在optimizer.h新增优化函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">OptimizePredicatePushdown</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef</span>;</span><br></pre></td></tr></table></figure>\n<p>同样在optimizer_custom_rules.cpp中实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizePredicatePushdown</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; optimized_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    optimized_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizePredicatePushdown</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> optimized_plan = plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(optimized_children));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Plan Should be a filter node.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Filter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> filter_plan = <span class=\"built_in\">dynamic_cast</span>&lt;FilterPlanNode *&gt;(optimized_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    std::vector&lt;std::shared_ptr&lt;ComparisonExpression&gt;&gt; pushdowns;</span><br><span class=\"line\">    filter_plan-&gt;predicate_ = <span class=\"built_in\">ParsePredicate</span>(filter_plan-&gt;predicate_, filter_plan-&gt;<span class=\"built_in\">OutputSchema</span>(), pushdowns);</span><br><span class=\"line\">    <span class=\"comment\">// No predicate could be pushed down, simply return.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pushdowns.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// All predicate could be pushed down, remove the filter node.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filter_plan-&gt;predicate_ == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Pushdown</span>(filter_plan-&gt;children_[<span class=\"number\">0</span>], pushdowns);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Part of predicate could be pushed down.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> filter_plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(&#123;<span class=\"built_in\">Pushdown</span>(filter_plan-&gt;children_[<span class=\"number\">0</span>], pushdowns)&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有几个helper method我就不放出了，说一下思路：</p>\n<p>首先要获取predicate， 而predicate存在filter node中，所以当遇到一个filter node，用<strong>ParsePredicate()</strong> 来获取predicate。这个函数输入值<strong>filter_plan-&gt;predicate_<strong>是一个tree，递归遍历处理这个tree，将用</strong>AND</strong>连接的<strong>ComparisonExpression</strong>加入<strong>pushdowns</strong>这个vector，遇到OR则停止直接保持原样返回。加入pushdowns的expression要从原树中剔除。</p>\n<p>这样就获得了需要下推的predicates，将这些predicates和子节点放入下推函数**Pushdown()**。Pushdown中对遇到的各种类型的plan node分类处理，有的可以直接跳过，有的会阻塞下推，有的会使下推分叉(join node)。 类似：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::Pushdown</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                         std::vector&lt;std::shared_ptr&lt;ComparisonExpression&gt;&gt; &amp;pushdowns)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pushdowns.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> plan;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Check if plan is Filter.</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (plan-&gt;<span class=\"built_in\">GetType</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::NestedLoopJoin: &#123;</span><br><span class=\"line\">      TODO: ... ... </span><br><span class=\"line\">      <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Skip these nodes.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Filter:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Limit:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Sort: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::vector&lt;AbstractPlanNodeRef&gt;&#123;<span class=\"built_in\">Pushdown</span>(plan-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">0</span>), pushdowns)&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Block pushdown, generate a filter plan above it.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::SeqScan:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::MockScan:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Aggregation:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Window:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Delete:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Update:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Insert:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::Projection:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::InitCheck: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;FilterPlanNode&gt;(plan-&gt;output_schema_, <span class=\"built_in\">ConcatencateComparisonAnd</span>(pushdowns), plan);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Advanced planNode, they should be generated latter.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::TopNPerGroup:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::TopN:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::HashJoin:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PlanType::NestedIndexJoin: &#123;</span><br><span class=\"line\">      <span class=\"built_in\">UNREACHABLE</span>(<span class=\"string\">&quot;This kind of node should not appear in pushdown. They should be made after pushdown.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">      <span class=\"built_in\">UNREACHABLE</span>(<span class=\"string\">&quot;Not supported planNode type.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>其中最复杂的就是遇到<strong>NestedLoopJoin</strong>，记得要修改像右子树继续下推的predicates的<strong>col_idx</strong>。</p>\n<p>当推到可以合并的节点，如seq_scan、NLJ的时候，只需要在其上方建一个filter node，因为后续其他的优化函数会帮你合并。而<strong>OptimizePredicatePushdown</strong>我是放在了<strong>Optimizer::OptimizeCustom</strong>中的靠前位置，这样可以先下推，再合并，优化调理清晰，充分利用已经写好的其他优化函数。</p>\n<p>实现下推后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">HashJoin &#123; type=Inner, left_key=[&quot;#0.3&quot;], right_key=[&quot;#1.1&quot;] &#125; </span><br><span class=\"line\">| (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER, t6.x:INTEGER, t6.y:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">HashJoin &#123; type=Inner, left_key=[&quot;#0.0&quot;], right_key=[&quot;#1.0&quot;] &#125; </span><br><span class=\"line\">| (t4.x:INTEGER, t4.y:INTEGER, t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">SeqScan &#123; table=t4, filter=((#0.1&lt;1500000)and(#0.1&gt;=1000000)) &#125; </span><br><span class=\"line\">| (t4.x:INTEGER, t4.y:INTEGER)</span><br><span class=\"line\">   </span><br><span class=\"line\">SeqScan &#123; table=t5 &#125; | (t5.x:INTEGER, t5.y:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">SeqScan &#123; table=t6, filter=((#0.0&lt;150000)and(#0.0&gt;=100000)) &#125;</span><br><span class=\"line\">| (t6.x:INTEGER, t6.y:INTEGER)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HashJoin: t4.y = t6.y</span><br><span class=\"line\">| Output: (t4.x, t4.y, t5.x, t5.y, t6.x, t6.y)</span><br><span class=\"line\">│</span><br><span class=\"line\">├── HashJoin: t4.x = t5.x</span><br><span class=\"line\">│   | Output: (t4.x, t4.y, t5.x, t5.y)</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   ├── SeqScan: table=t4</span><br><span class=\"line\">│   │   | Filter: (t4.y &gt;= 1000000) AND (t4.y &lt; 1500000)</span><br><span class=\"line\">│   │   | Output: (t4.x, t4.y)</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   └── SeqScan: table=t5</span><br><span class=\"line\">│       | No Filter</span><br><span class=\"line\">│       | Output: (t5.x, t5.y)</span><br><span class=\"line\">│</span><br><span class=\"line\">└── SeqScan: table=t6</span><br><span class=\"line\">    | Filter: (t6.x &gt;= 100000) AND (t6.x &lt; 150000)</span><br><span class=\"line\">    | Output: (t6.x, t6.y)</span><br></pre></td></tr></table></figure>\n<p>可看到谓词被下推到合适的地方了。</p>\n<p>此时leaderboard q2用时1900多，排名第八。</p>\n<h2 id=\"进一步优化想法\"><a href=\"#进一步优化想法\" class=\"headerlink\" title=\"进一步优化想法\"></a>进一步优化想法</h2><ol>\n<li><strong>Join重排 join reorder</strong>。先估算表的大小，然后重排连接顺序，先join小表后join大表。</li>\n<li><strong>实现Hash join的比较左右表</strong>。估算左右表大小，从而用小表构造hash map。</li>\n<li><strong>limit&#x2F;agg 下推</strong>。但leaderboard test中没有针对此的测试，所以实现了对排名提高无用。</li>\n<li><strong>query复用计算结果</strong>。leaderboard测试逻辑貌似是把同一个query执行10次，所以实现储存query结果复用有可能可以大幅加速第2～10次query。</li>\n</ol>\n<h1 id=\"Query-3-The-Mad-Data-Scientist\"><a href=\"#Query-3-The-Mad-Data-Scientist\" class=\"headerlink\" title=\"Query 3: The Mad Data Scientist\"></a>Query 3: The Mad Data Scientist</h1><p>一名购买了恒太房产的数据科学家意识到自己的所作所为之后，写下了这些奇怪的query：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t7(v <span class=\"type\">int</span>, v1 <span class=\"type\">int</span>, v2 <span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t8(v4 <span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">explain <span class=\"keyword\">SELECT</span> v, d1, d2 <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> v,</span><br><span class=\"line\">         <span class=\"built_in\">MAX</span>(v1) <span class=\"keyword\">AS</span> d1, <span class=\"built_in\">MIN</span>(v1), <span class=\"built_in\">MAX</span>(v2), <span class=\"built_in\">MIN</span>(v2),</span><br><span class=\"line\">         <span class=\"built_in\">MAX</span>(v1) <span class=\"operator\">+</span> <span class=\"built_in\">MIN</span>(v1), <span class=\"built_in\">MAX</span>(v2) <span class=\"operator\">+</span> <span class=\"built_in\">MIN</span>(v2),</span><br><span class=\"line\">         <span class=\"built_in\">MAX</span>(v1) <span class=\"operator\">+</span> <span class=\"built_in\">MAX</span>(v1) <span class=\"operator\">+</span> <span class=\"built_in\">MAX</span>(v2) <span class=\"keyword\">AS</span> d2</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> t7 <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> (<span class=\"keyword\">SELECT</span> v4 <span class=\"keyword\">FROM</span> t8 <span class=\"keyword\">WHERE</span> <span class=\"number\">1</span> <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">2</span>) <span class=\"keyword\">ON</span> v <span class=\"operator\">&lt;</span> v4</span><br><span class=\"line\">    <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> v</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>可以看到有很多奇怪的东西，比如始终等于false的</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"number\">1</span> <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>还有计算了这些数据，但并没有输出：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">MIN</span>(v1), <span class=\"built_in\">MAX</span>(v2), <span class=\"built_in\">MIN</span>(v2),</span><br><span class=\"line\"><span class=\"built_in\">MAX</span>(v1) <span class=\"operator\">+</span> <span class=\"built_in\">MIN</span>(v1), <span class=\"built_in\">MAX</span>(v2) <span class=\"operator\">+</span> <span class=\"built_in\">MIN</span>(v2),</span><br></pre></td></tr></table></figure>\n<p>第一个始终等于false的表达式考察的是优化器**常量折叠(constant folding)<strong>能力，而第二个去除冗余的计算考察的是优化器列</strong>剪枝(Column pruning)**的能力。</p>\n<p>先看看优化前：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;, &quot;#0.7&quot;] &#125; | (__subquery#0.t7.v:INTEGER, __subquery#0.d1:INTEGER, __subquery#0.d2:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">  Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;, &quot;#0.3&quot;, &quot;#0.4&quot;, &quot;(#0.5+#0.6)&quot;, &quot;(#0.7+#0.8)&quot;, &quot;((#0.9+#0.10)+#0.11)&quot;] &#125; | (__subquery#0.t7.v:INTEGER, __subquery#0.d1:INTEGER, __subquery#0.__item#2:INTEGER, __subquery#0.__item#3:INTEGER, __subquery#0.__item#4:INTEGER, __subquery#0.__item#5:INTEGER, __subquery#0.__item#6:INTEGER, __subquery#0.d2:INTEGER)</span><br><span class=\"line\">  </span><br><span class=\"line\">    Agg &#123; types=[&quot;max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;max&quot;, &quot;max&quot;], </span><br><span class=\"line\">    aggregates=[&quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;, &quot;#0.2&quot;, &quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;, &quot;#0.2&quot;, &quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;], </span><br><span class=\"line\">    group_by=[&quot;#0.0&quot;] &#125;</span><br><span class=\"line\">   \t| (t7.v:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER, agg#3:INTEGER, agg#4:INTEGER, agg#5:INTEGER, agg#6:INTEGER, agg#7:INTEGER, agg#8:INTEGER, agg#9:INTEGER, agg#10:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">      Filter &#123; predicate=(#0.0&lt;#0.3) &#125; | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER, __subquery#1.t8.v4:INTEGER)</span><br><span class=\"line\">      </span><br><span class=\"line\">        HashJoin &#123; type=Left, left_key=[], right_key=[] &#125; | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER, __subquery#1.t8.v4:INTEGER)</span><br><span class=\"line\">        </span><br><span class=\"line\">          SeqScan &#123; table=t7 &#125; | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER)</span><br><span class=\"line\">          </span><br><span class=\"line\">          SeqScan &#123; table=t8, filter=(1=2) &#125; | (t8.v4:INTEGER)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection: (__subquery#0.t7.v, __subquery#0.d1, __subquery#0.d2)</span><br><span class=\"line\">│</span><br><span class=\"line\">└── Projection: (__subquery#0.t7.v, __subquery#0.d1, __subquery#0.d2, derived columns)</span><br><span class=\"line\">    │</span><br><span class=\"line\">    └── Aggregation: Group by (t7.v), Aggregates: max/min</span><br><span class=\"line\">        │</span><br><span class=\"line\">        └── Filter: (t7.v &lt; __subquery#1.t8.v4)</span><br><span class=\"line\">            │</span><br><span class=\"line\">            └── HashJoin: Left Join (t7, t8)</span><br><span class=\"line\">                │</span><br><span class=\"line\">                ├── Sequential Scan: t7</span><br><span class=\"line\">                │</span><br><span class=\"line\">                └── Sequential Scan: t8 (filtered: (1=2) )</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"常量折叠-Constant-Folding\"><a href=\"#常量折叠-Constant-Folding\" class=\"headerlink\" title=\"常量折叠 Constant Folding\"></a>常量折叠 Constant Folding</h2><p>常量折叠指的是优化器提前将可以计算的表达式计算出结果，否则每来一个tuple，表达式就要重新计算一次。</p>\n<p>在optimizer.h中增加declaration，并在optimizer_custom_rules.cpp中实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizeConstantFolding</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; optimized_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    optimized_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeConstantFolding</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> optimized_plan = plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(optimized_children));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// For filter, folding its predicate.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Filter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> filter_plan = <span class=\"built_in\">dynamic_cast</span>&lt;FilterPlanNode *&gt;(optimized_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> new_predicate = <span class=\"built_in\">FoldingPredicate</span>(filter_plan-&gt;predicate_);</span><br><span class=\"line\">    <span class=\"comment\">// If the new_predicate is constant, </span></span><br><span class=\"line\">    <span class=\"comment\">// true, return its child; false, return an empty value node.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> new_predicate_const = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ConstantValueExpression *&gt;(new_predicate.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_predicate_const-&gt;<span class=\"built_in\">Evaluate</span>(&#123;&#125;, <span class=\"built_in\">Schema</span>(&#123;&#125;)).<span class=\"built_in\">GetAs</span>&lt;<span class=\"type\">bool</span>&gt;()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> plan-&gt;children_[<span class=\"number\">0</span>];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;ValuesPlanNode&gt;(plan-&gt;output_schema_, std::vector&lt;std::vector&lt;AbstractExpressionRef&gt;&gt;&#123;&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// new_predicate is not a constant, return a new filter.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;FilterPlanNode&gt;(filter_plan-&gt;output_schema_, new_predicate, filter_plan-&gt;children_[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现常量折叠后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Query Execution Plan</span><br><span class=\"line\"></span><br><span class=\"line\">Projection: (output columns: #0.0, #0.1, #0.7)</span><br><span class=\"line\">│</span><br><span class=\"line\">└── Projection: (output columns: #0.0, #0.1, #0.2, #0.3, #0.4, (#0.5 + #0.6), (#0.7 + #0.8), ((#0.9 + #0.10) + #0.11))</span><br><span class=\"line\">    │</span><br><span class=\"line\">    └── Aggregation: Group By (#0.0), Aggregates (max/min on #0.1, #0.2)</span><br><span class=\"line\">        │</span><br><span class=\"line\">        └── Filter: (#0.0 &lt; #0.3)</span><br><span class=\"line\">            │</span><br><span class=\"line\">            └── HashJoin: Left Join</span><br><span class=\"line\">                │</span><br><span class=\"line\">                ├── Sequential Scan: t7</span><br><span class=\"line\">                │</span><br><span class=\"line\">                └── Values: (empty set, rows=0)</span><br></pre></td></tr></table></figure>\n<p>可见seq_scan t8 被折叠成空的Value node了。此时可以对Join进行优化，如果右孩为空，直接返回左孩(left join)或直接返回false(inner join)。<strong>但目前不可以直接删除Join，因为join之后schema会改变。</strong></p>\n<p>此时只折叠了filter里的expressions，这虽然已经足够应付测试，但你还可以将其余有expressions的plan都给折叠了，这就不贴出来了，留给读者实现。</p>\n<h2 id=\"列剪枝-ColumnPruning\"><a href=\"#列剪枝-ColumnPruning\" class=\"headerlink\" title=\"列剪枝 ColumnPruning\"></a>列剪枝 ColumnPruning</h2><p>可以看到实现常量折叠后的执行树中，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection: (output columns: #0.0, #0.1, #0.7)</span><br></pre></td></tr></table></figure>\n<p>最终结果只输出#0.0 #0.1 #0.7，但aggregate却计算了一长串：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection: (output columns: #0.0, #0.1, #0.2, #0.3, #0.4, (#0.5 + #0.6), (#0.7 + #0.8), ((#0.9 + #0.10) + #0.11)</span><br></pre></td></tr></table></figure>\n<p>所以当Projection的子节点为Projection或者Aggregation的时候，可以对子节点进行剪枝，避免不需要的计算和内存占用。注意，Column Pruning一定要自上而下，否则会导致pruning不完全。</p>\n<p>第二个projection应pruned为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection: (output columns: #0.0, #0.1, #0.2, #0.3, #0.4, (#0.5 + #0.6), (#0.7 + #0.8), ((#0.9 + #0.10) + #0.11))</span><br><span class=\"line\">\t\t\t\t\t\t\t｜</span><br><span class=\"line\">\t\t\t\t\t\t\t｜</span><br><span class=\"line\">\t\t\t\t\t\t\t\\/</span><br><span class=\"line\">Projection: (output columns: #0.0, #0.1, ((#0.9 + #0.10) + #0.11))\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br></pre></td></tr></table></figure>\n\n<p>对于 Projection 结点, 分别处理子结点为 Projection 和 Aggregation 的情况.</p>\n<ul>\n<li>对于 Projection 结点, 用父节点对子结点修剪, 然后用子结点替换父节点.</li>\n<li>对于 Aggregation 结点, 用 Projection 中出现的列检查 Aggregation 中是否出现, 若没有则删除. 同时检查是否存在冗余, 若存在则删除.<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizeColumnPruning</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;<span class=\"type\">const</span> AbstractPlanNode&gt; optimized_plan = plan;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode *&gt;(optimized_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> child_plan = projection_plan-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pruning when child is Projection.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Collect used cols.</span></span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">uint32_t</span>&gt; used_col_idxs;</span><br><span class=\"line\">      used_col_idxs.<span class=\"built_in\">reserve</span>(optimized_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumnCount</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CollectUsedColumnIdx</span>(expr, used_col_idxs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      std::<span class=\"built_in\">sort</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">      <span class=\"comment\">// Prune child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> child_projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode *&gt;(child_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_exprs;</span><br><span class=\"line\">      std::vector&lt;Column&gt; pruned_columns;</span><br><span class=\"line\">      pruned_exprs.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_columns.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> idx : used_col_idxs) &#123;</span><br><span class=\"line\">        pruned_exprs.<span class=\"built_in\">push_back</span>(child_projection_plan-&gt;expressions_[idx]);</span><br><span class=\"line\">        pruned_columns.<span class=\"built_in\">push_back</span>(child_projection_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(idx));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Replace parent by its optimized child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> optimized_child_plan = std::<span class=\"built_in\">make_shared</span>&lt;ProjectionPlanNode&gt;(std::<span class=\"built_in\">make_shared</span>&lt;Schema&gt;(pruned_columns), </span><br><span class=\"line\">          pruned_exprs, child_plan-&gt;children_[<span class=\"number\">0</span>]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">OptimizeColumnPruning</span>(optimized_child_plan);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pruning when child is Aggregation.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Aggregation) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Collect used cols.</span></span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">uint32_t</span>&gt; used_col_idxs;</span><br><span class=\"line\">      used_col_idxs.<span class=\"built_in\">reserve</span>(optimized_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumnCount</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CollectUsedColumnIdx</span>(expr, used_col_idxs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      std::<span class=\"built_in\">sort</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">      <span class=\"comment\">// Prune child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> child_aggregation_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> AggregationPlanNode *&gt;(child_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">      <span class=\"type\">size_t</span> group_col_length = child_aggregation_plan-&gt;group_bys_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_aggregates;</span><br><span class=\"line\">      std::vector&lt;AggregationType&gt; pruned_agg_types;</span><br><span class=\"line\">      std::vector&lt;Column&gt; pruned_columns;</span><br><span class=\"line\">      pruned_aggregates.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_agg_types.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_columns.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; group_col_length; ++i) &#123;</span><br><span class=\"line\">        pruned_columns.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(i));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> idx : used_col_idxs) &#123; <span class=\"comment\">// Maybe optimized to binary, upper_bound.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt;= group_col_length) &#123;</span><br><span class=\"line\">          pruned_aggregates.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;aggregates_[idx - group_col_length]);</span><br><span class=\"line\">          pruned_agg_types.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;agg_types_[idx - group_col_length]);</span><br><span class=\"line\">          pruned_columns.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(idx));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Make new optimized node child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> optimized_aggr = std::<span class=\"built_in\">make_shared</span>&lt;AggregationPlanNode&gt;(</span><br><span class=\"line\">          std::<span class=\"built_in\">make_shared</span>&lt;Schema&gt;(pruned_columns), child_aggregation_plan-&gt;children_[<span class=\"number\">0</span>], </span><br><span class=\"line\">          child_aggregation_plan-&gt;group_bys_, pruned_aggregates, pruned_agg_types);</span><br><span class=\"line\">      <span class=\"comment\">// Modified parent node schema and expr.</span></span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_exprs;</span><br><span class=\"line\">      pruned_exprs.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        pruned_exprs.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">PrunedProjectionExpression</span>(expr, used_col_idxs));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      optimized_plan = std::<span class=\"built_in\">make_shared</span>&lt;ProjectionPlanNode&gt;(projection_plan-&gt;output_schema_, pruned_exprs, optimized_aggr);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> optimized_plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(&#123;<span class=\"built_in\">OptimizeColumnPruning</span>(optimized_plan-&gt;children_[<span class=\"number\">0</span>])&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::SeqScan || optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::MockScan ||</span><br><span class=\"line\">      optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::IndexScan) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; new_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    new_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeColumnPruning</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(new_children));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n到了这里，我也发现了我OptimizeNLJAsHashJoin()的一个bug，要在OptimizeNLJAsHashJoin()中需要加一行：<strong>当尝试在Join Node上方生成新的filter Node时候，如join类型不是Inner Join, 要保持NLJ而不能优化成Hash_Join</strong>。</li>\n</ul>\n<p>我实现OptimizeNLJAsHashJoin()的时候会尝试多生成一个filter Node，但是如果是Left Join 的话，Join后的tuple中有可能出现null value，而新的filer有可能会导致这些包含null value的tuple全被去除掉。所以在Left Join的时候，要保持去除的判断语句在Join Node内部，而不能剥离开。所以其实gradescope上给的基础测试非常不全面，即使通过所以测试，代码也可能有很多很大的bug。</p>\n<p>debug并优化后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;, &quot;((#0.2+#0.3)+#0.4)&quot;] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Agg &#123; types=[&quot;max&quot;, &quot;max&quot;, &quot;max&quot;, &quot;max&quot;]</span><br><span class=\"line\">  ,aggregates=[&quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;]</span><br><span class=\"line\">  ,group_by=[&quot;#0.0&quot;] &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    NestedLoopJoin &#123; type=Left, predicate=(#0.0&lt;#1.0) &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">      MockScan &#123; table=__mock_t7 &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      Values &#123; rows=0 &#125;</span><br></pre></td></tr></table></figure>\n<p>此时已经可以较快地通过q3了，但你会发现，aggr中居然还有重复的计算:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">types=     [&quot;max&quot;,  &quot;max&quot;,  &quot;max&quot;,  &quot;max&quot;],</span><br><span class=\"line\">aggregates=[&quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.1&quot;, &quot;#0.2&quot;]</span><br></pre></td></tr></table></figure>\n<p>对齐一下，显然对#0.1的max居然计算了三遍…所以可以进一步对aggregation去重。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Optimizer::CollectUsedColumnIdx</span><span class=\"params\">(<span class=\"type\">const</span> AbstractExpressionRef &amp;expr, std::vector&lt;<span class=\"type\">uint32_t</span>&gt; &amp;col_idxs)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> *arith_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ArithmeticExpression*&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CollectUsedColumnIdx</span>(expr-&gt;children_[<span class=\"number\">0</span>], col_idxs);</span><br><span class=\"line\">    <span class=\"built_in\">CollectUsedColumnIdx</span>(expr-&gt;children_[<span class=\"number\">1</span>], col_idxs);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> *column_value_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ColumnValueExpression *&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">find</span>(col_idxs.<span class=\"built_in\">begin</span>(), col_idxs.<span class=\"built_in\">end</span>(), column_value_expr-&gt;<span class=\"built_in\">GetColIdx</span>()) == col_idxs.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      col_idxs.<span class=\"built_in\">push_back</span>(column_value_expr-&gt;<span class=\"built_in\">GetColIdx</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ConstantValueExpression *&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  std::string message = <span class=\"string\">&quot;Projection expressions should only contain arithmetic, column and constant: &quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">UNREACHABLE</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::PrunedProjectionExpression</span><span class=\"params\">(<span class=\"type\">const</span> AbstractExpressionRef &amp;expr, std::vector&lt;<span class=\"type\">int</span>&gt; idx_map)</span> </span></span><br><span class=\"line\"><span class=\"function\">    -&gt; AbstractExpressionRef </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Notice: used_col_idxs is sorted.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> *arith_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ArithmeticExpression *&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expr-&gt;<span class=\"built_in\">CloneWithChildren</span>(&#123;<span class=\"built_in\">PrunedProjectionExpression</span>(expr-&gt;children_[<span class=\"number\">0</span>], idx_map),</span><br><span class=\"line\">                                    <span class=\"built_in\">PrunedProjectionExpression</span>(expr-&gt;children_[<span class=\"number\">1</span>], idx_map)&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> *column_value_expr = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ColumnValueExpression *&gt;(expr.<span class=\"built_in\">get</span>())) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> new_col_idx = idx_map[column_value_expr-&gt;<span class=\"built_in\">GetColIdx</span>()];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;ColumnValueExpression&gt;(column_value_expr-&gt;<span class=\"built_in\">GetTupleIdx</span>(), new_col_idx, </span><br><span class=\"line\">        column_value_expr-&gt;<span class=\"built_in\">GetReturnType</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> expr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::OptimizeColumnPruning</span><span class=\"params\">(<span class=\"type\">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;<span class=\"type\">const</span> AbstractPlanNode&gt; optimized_plan = plan;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode *&gt;(optimized_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> child_plan = projection_plan-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pruning when child is Projection.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Projection) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Collect used cols.</span></span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">uint32_t</span>&gt; used_col_idxs;</span><br><span class=\"line\">      used_col_idxs.<span class=\"built_in\">reserve</span>(optimized_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumnCount</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CollectUsedColumnIdx</span>(expr, used_col_idxs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      std::<span class=\"built_in\">sort</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">      <span class=\"comment\">// Prune child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> child_projection_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> ProjectionPlanNode *&gt;(child_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_exprs;</span><br><span class=\"line\">      std::vector&lt;Column&gt; pruned_columns;</span><br><span class=\"line\">      pruned_exprs.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_columns.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> idx : used_col_idxs) &#123;</span><br><span class=\"line\">        pruned_exprs.<span class=\"built_in\">push_back</span>(child_projection_plan-&gt;expressions_[idx]);</span><br><span class=\"line\">        pruned_columns.<span class=\"built_in\">push_back</span>(child_projection_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(idx));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Replace parent by its optimized child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> optimized_child_plan = std::<span class=\"built_in\">make_shared</span>&lt;ProjectionPlanNode&gt;(std::<span class=\"built_in\">make_shared</span>&lt;Schema&gt;(pruned_columns), </span><br><span class=\"line\">          pruned_exprs, child_plan-&gt;children_[<span class=\"number\">0</span>]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">OptimizeColumnPruning</span>(optimized_child_plan);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pruning when child is Aggregation.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Aggregation) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">auto</span> child_aggregation_plan = <span class=\"built_in\">dynamic_cast</span>&lt;<span class=\"type\">const</span> AggregationPlanNode *&gt;(child_plan.<span class=\"built_in\">get</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Collect used cols.</span></span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">uint32_t</span>&gt; used_col_idxs;</span><br><span class=\"line\">      used_col_idxs.<span class=\"built_in\">reserve</span>(optimized_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumnCount</span>());</span><br><span class=\"line\">      <span class=\"type\">size_t</span> group_cols = child_aggregation_plan-&gt;<span class=\"built_in\">GetGroupBys</span>().<span class=\"built_in\">size</span>();</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; group_cols; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Must use group by columns.</span></span><br><span class=\"line\">        used_col_idxs.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CollectUsedColumnIdx</span>(expr, used_col_idxs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      std::<span class=\"built_in\">sort</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Prune child.</span></span><br><span class=\"line\">      <span class=\"type\">size_t</span> group_col_length = child_aggregation_plan-&gt;group_bys_.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_aggregates;</span><br><span class=\"line\">      std::vector&lt;AggregationType&gt; pruned_agg_types;</span><br><span class=\"line\">      std::vector&lt;Column&gt; pruned_columns;</span><br><span class=\"line\">      <span class=\"comment\">// For aggr deduplication, [expression.toString + AggregationType]</span></span><br><span class=\"line\">      std::unordered_map&lt;std::string, <span class=\"type\">uint32_t</span>&gt; exist_expr;</span><br><span class=\"line\">      std::unordered_map&lt;<span class=\"type\">uint32_t</span>, <span class=\"type\">uint32_t</span>&gt; re_direct;</span><br><span class=\"line\"></span><br><span class=\"line\">      pruned_aggregates.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_agg_types.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      pruned_columns.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; group_col_length; ++i) &#123;</span><br><span class=\"line\">        pruned_columns.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(i));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> idx : used_col_idxs) &#123; <span class=\"comment\">// Maybe optimized to binary, upper_bound.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt;= group_col_length) &#123;  <span class=\"comment\">// idx &gt;= group_col_length means it&#x27;s aggr.</span></span><br><span class=\"line\">          <span class=\"keyword\">auto</span> aggr_expr = child_aggregation_plan-&gt;aggregates_[idx - group_col_length];</span><br><span class=\"line\">          <span class=\"keyword\">auto</span> aggr_type = child_aggregation_plan-&gt;agg_types_[idx - group_col_length];</span><br><span class=\"line\">          std::string aggr_pair = aggr_expr-&gt;<span class=\"built_in\">ToString</span>() + std::<span class=\"built_in\">to_string</span>(<span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(aggr_type));</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (exist_expr.<span class=\"built_in\">count</span>(aggr_pair) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Not exist yet, add to pruned lists.</span></span><br><span class=\"line\">            pruned_aggregates.<span class=\"built_in\">push_back</span>(aggr_expr);</span><br><span class=\"line\">            pruned_agg_types.<span class=\"built_in\">push_back</span>(aggr_type);</span><br><span class=\"line\">            pruned_columns.<span class=\"built_in\">push_back</span>(child_aggregation_plan-&gt;output_schema_-&gt;<span class=\"built_in\">GetColumn</span>(idx));</span><br><span class=\"line\">            exist_expr[aggr_pair] = pruned_columns.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Has existed, add to re_direct map.</span></span><br><span class=\"line\">            re_direct[idx] = exist_expr.<span class=\"built_in\">find</span>(aggr_pair)-&gt;second;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Make new optimized node child.</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> optimized_aggr = std::<span class=\"built_in\">make_shared</span>&lt;AggregationPlanNode&gt;(</span><br><span class=\"line\">          std::<span class=\"built_in\">make_shared</span>&lt;Schema&gt;(pruned_columns), child_aggregation_plan-&gt;children_[<span class=\"number\">0</span>], </span><br><span class=\"line\">          child_aggregation_plan-&gt;group_bys_, pruned_aggregates, pruned_agg_types);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Modified parent node schema and expr.</span></span><br><span class=\"line\">      std::vector&lt;AbstractExpressionRef&gt; pruned_exprs;</span><br><span class=\"line\">      pruned_exprs.<span class=\"built_in\">reserve</span>(used_col_idxs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">      std::vector&lt;<span class=\"type\">int</span>&gt; idx_map = <span class=\"built_in\">RearrangeColIdxs</span>(re_direct, used_col_idxs);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;expr : projection_plan-&gt;expressions_) &#123;</span><br><span class=\"line\">        pruned_exprs.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">PrunedProjectionExpression</span>(expr, idx_map));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      optimized_plan = std::<span class=\"built_in\">make_shared</span>&lt;ProjectionPlanNode&gt;(projection_plan-&gt;output_schema_, pruned_exprs, optimized_aggr);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> optimized_plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(&#123;<span class=\"built_in\">OptimizeColumnPruning</span>(optimized_plan-&gt;children_[<span class=\"number\">0</span>])&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::SeqScan || optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::MockScan ||</span><br><span class=\"line\">      optimized_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::IndexScan) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> optimized_plan;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::vector&lt;AbstractPlanNodeRef&gt; new_children&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;children_) &#123;</span><br><span class=\"line\">    new_children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeColumnPruning</span>(child));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(new_children));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Optimizer::RearrangeColIdxs</span><span class=\"params\">(std::unordered_map&lt;<span class=\"type\">uint32_t</span>, <span class=\"type\">uint32_t</span>&gt; &amp;re_direct, std::vector&lt;<span class=\"type\">uint32_t</span>&gt; &amp;used_col_idxs)</span> </span></span><br><span class=\"line\"><span class=\"function\">    -&gt; std::vector&lt;<span class=\"type\">int</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Initialize the result map and the del array</span></span><br><span class=\"line\">  <span class=\"type\">int</span> max_col_idx = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(used_col_idxs.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">  <span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">col_idx_map</span><span class=\"params\">(max_col_idx + <span class=\"number\">1</span>, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">del</span><span class=\"params\">(max_col_idx + <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Cache the result of std::lower_bound for each i</span></span><br><span class=\"line\">  <span class=\"function\">std::vector&lt;<span class=\"type\">uint32_t</span>&gt; <span class=\"title\">idx_map</span><span class=\"params\">(max_col_idx + <span class=\"number\">1</span>, used_col_idxs.size())</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= max_col_idx; ++i) &#123;</span><br><span class=\"line\">    idx_map[i] = std::<span class=\"built_in\">find</span>(used_col_idxs.<span class=\"built_in\">begin</span>(), used_col_idxs.<span class=\"built_in\">end</span>(), i) - used_col_idxs.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// First pass: Fill col_idx_map and update del</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= max_col_idx; ++i) &#123; <span class=\"comment\">// 11</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> idx = idx_map[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; used_col_idxs.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (re_direct.<span class=\"built_in\">count</span>(i)) &#123;</span><br><span class=\"line\">        col_idx_map[i] = re_direct[i];</span><br><span class=\"line\">        del[idx + <span class=\"number\">1</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// When it&#x27;s not in re_direct.</span></span><br><span class=\"line\">        col_idx_map[i] = idx;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Compute cumulative del values</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">1</span>; i &lt; del.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">    del[i] += del[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Final adjustment for col_idx_map</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= max_col_idx; ++i) &#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> idx = idx_map[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (col_idx_map[i] != <span class=\"number\">-1</span> &amp;&amp; !re_direct.<span class=\"built_in\">count</span>(idx)) &#123;</span><br><span class=\"line\">      col_idx_map[i] += del[col_idx_map[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;re_direct:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printUnorderedMap(re_direct);</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;idx_map:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printVector(idx_map);</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;del:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printVector(del);</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;used_col_idxs:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printVector(used_col_idxs);</span></span><br><span class=\"line\"><span class=\"comment\">    printf(&quot;col_idx_map:&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    printVector(col_idx_map);</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> col_idx_map;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优化后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Projection &#123; exprs=[&quot;#0.0&quot;, &quot;#0.1&quot;, &quot;((#0.1+#0.1)+#0.2)&quot;] &#125; </span><br><span class=\"line\">| (__subquery#0.t7.v:INTEGER, __subquery#0.d1:INTEGER, __subquery#0.d2:INTEGER)</span><br><span class=\"line\"></span><br><span class=\"line\">  Agg &#123; types=[&quot;max&quot;, &quot;max&quot;], aggregates=[&quot;#0.1&quot;, &quot;#0.2&quot;], group_by=[&quot;#0.0&quot;] &#125; </span><br><span class=\"line\">  | (t7.v:INTEGER, agg#0:INTEGER, agg#10:INTEGER)</span><br><span class=\"line\">  </span><br><span class=\"line\">    NestedLoopJoin &#123; type=Left, predicate=(#0.0&lt;#1.0) &#125; </span><br><span class=\"line\">    | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER, __subquery#1.t8.v4:INTEGER)</span><br><span class=\"line\">    </span><br><span class=\"line\">      SeqScan &#123; table=t7 &#125; | (t7.v:INTEGER, t7.v1:INTEGER, t7.v2:INTEGER)</span><br><span class=\"line\">      </span><br><span class=\"line\">      Values &#123; rows=0 &#125; | (__subquery#1.t8.v4:INTEGER)</span><br></pre></td></tr></table></figure>\n<p>可见aggr只计算了两个max。</p>\n<p>现在q3用时可以达到700多，并且其他测试也都可以通过。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>由于给的基础测试太不全面了，导致我自己又写了一点，但仍然不全面。所以<strong>实际上我的代码肯定还有bug</strong>，只是还没找到且不影响线上测试。想用线上测试就必须要遵循一些代码格式，比如不能新增文件，某些函数只能写在特定文件，大部分初始代码不能自己修改…这些东西很大地限制了发挥，真诚希望以后能改进一下，给我们更多自由度，至少能新增文件吧。。。</p>\n<p>目前三个leaderboard test总分排名进了前十，而事实上23fall也没有多少人真正完成了project 3 的全部leaderboard部分。所谓的cmu15445烂大街，其实确实是个谎言。事实上23fall的project 3 leaderboard做完的只有不到20个人，更别说project 4了。</p>\n<p><strong>我认为project 3是最重要的一个project</strong>。做过前两个project的都知道，project 1、2 和数据库结构真没啥太大关系。所以当我做完1、2的时候，对数据库具体结构是几乎没有进一步了解。而project 3 才是真正深入Bustub执行过程，我做完3后才对数据库各个组件有了一个真正直观的认识。非常推荐自己认真完成这个project。</p>\n<p>贴出来的代码跟一坨答辩一样，后续我对代码进行了一些重构，但现在真是累死了，写不动了。但话说起来，这一坨也让读者阅读起来更困难，也算间接保护了课程无法被抄袭。。。</p>\n","categories":["数据库"],"tags":["数据库","Bustub"]}]